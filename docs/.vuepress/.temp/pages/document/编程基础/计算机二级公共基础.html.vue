<template><div><h2 id="第1章-计算机系统" tabindex="-1"><a class="header-anchor" href="#第1章-计算机系统" aria-hidden="true">#</a> 第1章 计算机系统</h2>
<h3 id="_1-1-概述" tabindex="-1"><a class="header-anchor" href="#_1-1-概述" aria-hidden="true">#</a> <strong>1.1 概述</strong></h3>
<h4 id="_1-1-1-计算机的发展历程" tabindex="-1"><a class="header-anchor" href="#_1-1-1-计算机的发展历程" aria-hidden="true">#</a> <strong>1.1.1 计算机的发展历程</strong></h4>
<ol>
<li>
<p>计算机发展的四个阶段</p>
</li>
<li>
<ol>
<li>第一台数字电子计算机ENIAC在美国某大学，每秒可运行5千次加法</li>
</ol>
</li>
<li>
<p>电子管时代，晶体管时代，集成电路时代，大规模集成电路时代</p>
</li>
<li></li>
</ol>
<h4 id="_1-1-2-计算机体系结构" tabindex="-1"><a class="header-anchor" href="#_1-1-2-计算机体系结构" aria-hidden="true">#</a> <strong>1.1.2    计算机体系结构</strong></h4>
<ol>
<li>
<p>冯诺依曼计算机结构</p>
</li>
<li>
<ol>
<li>计算机硬件由运算器，存储器，控制器，输设备，输出设备组成</li>
</ol>
</li>
<li>
<p>计算机内部采用二进制表示指令和数据</p>
</li>
<li>
<p>需要将编号的程序和原始数据先存入存储器中，再启动计算机工作</p>
</li>
<li>
<p>非冯诺依曼计算机</p>
</li>
<li>
<ol>
<li>数据驱动的数据流计算机</li>
</ol>
</li>
<li>
<p>需求驱动的归约计算机</p>
</li>
<li>
<p>模式匹配驱动的智能计算机等</p>
</li>
<li>
<p>原始的冯诺依曼计算机在结构上以运算器为中心，现在转向了以储存器为中心</p>
</li>
</ol>
<h4 id="_1-1-3-计算机系统基本组成" tabindex="-1"><a class="header-anchor" href="#_1-1-3-计算机系统基本组成" aria-hidden="true">#</a> <strong>1.1.3 计算机系统基本组成</strong></h4>
<ol>
<li>
<p>完整的计算机应该包括：软件系统和硬件系统</p>
</li>
<li>
<p>计算机系统中的软件系统和硬件系统互相依赖，不可分割</p>
</li>
<li>
<p>软件可以分为系统软件和应用软件</p>
</li>
<li>
<ol>
<li>系统软件有操作系统，服务软件，编译与解释系统</li>
</ol>
</li>
<li>
<p>应用软件有信息管理软件，辅助设计软件，文字处理软件，图形软件，各种程序包</p>
</li>
<li></li>
</ol>
<h3 id="_1-2-计算机硬件系统" tabindex="-1"><a class="header-anchor" href="#_1-2-计算机硬件系统" aria-hidden="true">#</a> <strong>1.2 计算机硬件系统</strong></h3>
<h4 id="_1-2-1-中央处理器" tabindex="-1"><a class="header-anchor" href="#_1-2-1-中央处理器" aria-hidden="true">#</a> <strong>1.2.1 中央处理器</strong></h4>
<ol>
<li>
<p>中央处理器简称处理器，也叫CPU，是计算机系统的核心。</p>
</li>
<li>
<p>CPU包括两部分，控制器与运算器，他们都包含了寄存器或告诉存储区域，并用一种叫做总线的电子线路连接起来。</p>
</li>
<li>
<ol>
<li>控制器：整个计算机的控制中心和指挥中心</li>
</ol>
</li>
<li>
<p>运算器：执行算术运算和逻辑运算</p>
</li>
<li>
<p>寄存器：临时储存数据</p>
</li>
<li>
<p>总线：传输信息的电子数据线路</p>
</li>
<li></li>
</ol>
<h4 id="_1-2-2-计算机的基本工作原理" tabindex="-1"><a class="header-anchor" href="#_1-2-2-计算机的基本工作原理" aria-hidden="true">#</a> <strong>1.2.2 计算机的基本工作原理</strong></h4>
<ol>
<li>
<p>计算机采用二进制代码</p>
</li>
<li>
<p>一条指令由操作码和地址码组成</p>
</li>
<li>
<ol>
<li>操作码：指出指令的类型或性质</li>
</ol>
</li>
<li>
<p>地址码：描述该指令的操作对象</p>
</li>
<li>
<p>计算机指令系统是计算机所有指令的集合</p>
</li>
<li>
<p>计算机的工作就是自动快速的执行程序</p>
</li>
<li>
<ol>
<li>取指令，分析指令，执行指令，修改程序计数器</li>
</ol>
</li>
<li>
<p>CPU不断的取指令，分析指令，执行指令，这就是程序的执行过程</p>
</li>
</ol>
<h4 id="_1-2-3-存储器" tabindex="-1"><a class="header-anchor" href="#_1-2-3-存储器" aria-hidden="true">#</a> <strong>1.2.3 存储器</strong></h4>
<ol>
<li>
<p>分类：RAM存储器，只读存储器，闪速存储器，高速缓冲存储器</p>
</li>
<li>
<p>高速缓冲存储器通常被集成到CPU内部以提高访问速度</p>
</li>
</ol>
<h4 id="_1-2-4-数据的内部表示" tabindex="-1"><a class="header-anchor" href="#_1-2-4-数据的内部表示" aria-hidden="true">#</a> <strong>1.2.4 数据的内部表示</strong></h4>
<ol>
<li>
<p>无符号数是指非负整数</p>
</li>
<li>
<p>原码：最高位是符号位，0为整数，1为复数，数值在后面取绝对值</p>
</li>
<li>
<p>反码：正数的反码和原码相同，负数的反码是对原码除符号以外全部取反，一个数反码的反码还是原码本身</p>
</li>
<li>
<p>补码：正数的补码和原码相同，负数的补码是该数的反码最后一位加1，一个数的补码的补码还是原码本身</p>
</li>
<li>
<p>引入补码以后，计算机中带符号的数的加减运算都可以用加法实现，两数的补码之和等于两数和的补码</p>
</li>
</ol>
<h4 id="_1-2-5-总线和外设" tabindex="-1"><a class="header-anchor" href="#_1-2-5-总线和外设" aria-hidden="true">#</a> <strong>1.2.5 总线和外设</strong></h4>
<ol>
<li>总线的概念：总线是连接计算机中各个部件的信息传输线，是各个部件共享的传输介质。</li>
</ol>
<h3 id="_1-3-操作系统" tabindex="-1"><a class="header-anchor" href="#_1-3-操作系统" aria-hidden="true">#</a> <strong>1.3 操作系统</strong></h3>
<h4 id="_1-3-1-操作系统概述" tabindex="-1"><a class="header-anchor" href="#_1-3-1-操作系统概述" aria-hidden="true">#</a> <strong>1.3.1 操作系统概述</strong></h4>
<ol>
<li>
<p>操作系统的功能放入提供了进程管理，设备管理，文件管理，存储器管理，用户接口</p>
</li>
<li>
<p>操作系统的分类</p>
</li>
<li>
<ol>
<li>多道批处理操作系统：多道是指计算机内存中存入多个用户数据，批处理是指在外存中存入大量的后备作业，作业的运行完全由系统控制，用户与作业之间没有交互，批处理又叫脱机操作</li>
</ol>
</li>
<li>
<p>分时操作系统：允许多个联机用户同时使用一台计算机进行计算，用户之间的数据不可以共享</p>
</li>
<li>
<p>实时操作系统：快速处理和响应，如过程控制系统（火箭发射控制），信息查询系统（图书馆资料查询），事务处理系统（银行管理系统）</p>
</li>
<li>
<p>网络操作系统：将计算机加入网络中传送信息和共享网络资源的系统</p>
</li>
<li>
<p>分布式操作系统：由多台分散的计算机通过网络互连而成的系统，系统中的资料为所有用户共享，多台机器可以用互相协作来完成同一人物</p>
</li>
<li>
<p>嵌入式操作系统：运行在嵌入式系统之上的操作系统</p>
</li>
</ol>
<h4 id="_1-3-2-进程管理" tabindex="-1"><a class="header-anchor" href="#_1-3-2-进程管理" aria-hidden="true">#</a> <strong>1.3.2 进程管理</strong></h4>
<ol>
<li>
<p>顺序程序的特点：顺序性，封闭性，可再现性</p>
</li>
<li>
<p>并发程序特点</p>
</li>
<li>
<ol>
<li>没有封闭性</li>
</ol>
</li>
<li>
<p>程序与执行过程不是一一对应关系</p>
</li>
<li>
<p>程序并发执行可以互相制约</p>
</li>
<li>
<p>进程的概念：进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动，进程能从变化的角度，动态的反应并发程序活动</p>
</li>
<li>
<p>进程的状态：创建，就绪，运行，阻塞，终止</p>
</li>
<li>
<p>进程控制块 PCB 概念：能描述该进程执行情况，能反映该进程和其他进程以及系统资源的关系，能刻画该进程在各个不同时期所处的状态的数据块，即进程控制块</p>
</li>
<li>
<p>进程控制块是由系统为每个进程分别建立的，用以记录对应进程的程序和数据的存储情况，记录进程的动态信息，系统根据进程控制块PCB感知进程的存在，根据PCB中的信息对进程实施控制管理，PCB是一个进程存在的标志</p>
</li>
<li>
<p>进程调度算法：先来先服务调度算法，时间片轮转调度算法，优先级调度算法</p>
</li>
</ol>
<h4 id="_1-3-3-存储管理" tabindex="-1"><a class="header-anchor" href="#_1-3-3-存储管理" aria-hidden="true">#</a> <strong>1.3.3 存储管理</strong></h4>
<ol>
<li>
<p>存储管理的功能：地址变换，内存分配，存储共享与保护，存储器扩充</p>
</li>
<li>
<p>地址重定位：在进行地址变换时，对程序中的指令地址进行调整的过程</p>
</li>
<li>
<p>连续存储管理：内存被划分为一个个分区，一个作业占一个分区，简单兼容，但容易产生碎片</p>
</li>
<li>
<p>分页存储管理（内存空间管理）：作业空间被划分为页，实际内存空间被划分为块，页的大小与块的大小相等，有效的提高内存利用率</p>
</li>
<li>
<p>分段存储管理（地址空间管理）：作业的地址空间分为若干的逻辑分段，按段进行存储分配，能够反映程序的逻辑结构，实现段的共享</p>
</li>
<li>
<p>段页式存储管理：合并了两者的优点，但是没有独立的专业</p>
</li>
<li>
<p>虚拟存储器管理</p>
</li>
<li>
<ol>
<li>请求页式存储管理：与分页式存储管理不同， 如果作业的所有页面不是一次全部装入，而是根据作业运行时的实际要求只装入目前运行所要用到的一些页，其余的页仍保存在外存，等需要时再请求系统调入，称为请求页式存储管理</li>
</ol>
</li>
<li>
<p>请求段式存储管理：与请求页式存储管理相似，基于程序局部性原理，段式逻辑地址空间中的程序段在运行时也并不需要全部装入内存，而是在需要时再调入内存，若内存中没有足够大的空闲分区，则进行段的紧凑或淘汰某些段</p>
</li>
<li>
<p>请求页式存储管理提供了大容量的虚拟内存，可以容纳更多的作业进入系统，也能处理超出内存空间的作业，使用户的地址空间不再受内存大小的限制，所以要完成超出内存的作业时优先考虑请求页式存储管理的选项，其次再考虑请求段式存储管理</p>
</li>
</ol>
<h4 id="_1-3-4-文件管理" tabindex="-1"><a class="header-anchor" href="#_1-3-4-文件管理" aria-hidden="true">#</a> <strong>1.3.4 文件管理</strong></h4>
<ol>
<li>
<p>文件：是指一组带文件名的，在逻辑上有完整意义的信息项的序列</p>
</li>
<li>
<p>文件系统：是指负责存取和管理文件信息的软件机构</p>
</li>
<li>
<p>常用的文件系统：NFS，EXT2/4，HPFS，FAT，NTFS</p>
</li>
<li>
<p>文件目录概念：为了根据文件名存取文件，必须建立文件名与文件在外存空间中的物理地址的对应，表示这种对应关系的数据结构称为文件目录</p>
</li>
<li>
<p>文件系统用目录管理文件</p>
</li>
</ol>
<h4 id="_1-3-5-i-o设备管理" tabindex="-1"><a class="header-anchor" href="#_1-3-5-i-o设备管理" aria-hidden="true">#</a> <strong>1.3.5 I/O设备管理</strong></h4>
<ol>
<li>
<p>设备管理的作用：方便用户使用各种外部设备，为不同设备提供统一界面，发挥系统并行性且方便实用，使 IO 设备被高效利用</p>
</li>
<li>
<p>设备管理的功能：外围设备中断处理，缓冲区管理，外围设备的分配，外围设备驱动调度等</p>
</li>
</ol>
<hr>
<h2 id="第2章-数据结构与算法" tabindex="-1"><a class="header-anchor" href="#第2章-数据结构与算法" aria-hidden="true">#</a> <strong>第2章 数据结构与算法</strong></h2>
<h3 id="_2-1-算法" tabindex="-1"><a class="header-anchor" href="#_2-1-算法" aria-hidden="true">#</a> <strong>2.1 算法</strong></h3>
<h4 id="_2-1-1-算法的基本概念" tabindex="-1"><a class="header-anchor" href="#_2-1-1-算法的基本概念" aria-hidden="true">#</a> <strong>2.1.1 算法的基本概念</strong></h4>
<ol>
<li>
<p>算法概念：算法不等于程序，也不等于计算方法和计算公式</p>
</li>
<li>
<p>算法的基本特征：可行性，确定性，有穷性，拥有足够情报</p>
</li>
</ol>
<h4 id="_2-1-2-算法设计的基本方法" tabindex="-1"><a class="header-anchor" href="#_2-1-2-算法设计的基本方法" aria-hidden="true">#</a> <strong>2.1.2 算法设计的基本方法</strong></h4>
<ol>
<li>
<p>列举法：百钱买百鸡</p>
</li>
<li>
<p>归纳法：分析少量情况得出一般关系</p>
</li>
<li>
<p>递推：计算一加到一百</p>
</li>
<li>
<p>递归：调用自己</p>
</li>
</ol>
<h4 id="_2-1-3-算法复杂度" tabindex="-1"><a class="header-anchor" href="#_2-1-3-算法复杂度" aria-hidden="true">#</a> <strong>2.1.3 算法复杂度</strong></h4>
<ol>
<li>
<p>时间复杂度是描述算法运行时运算的次数和计算量</p>
</li>
<li>
<p>空间复杂度是描述算法运行时所需要额外的存储空间</p>
</li>
<li>
<p>压缩存储空间可以减小空间复杂度。</p>
</li>
<li>
<p>数据的储存结构会影响算法的效率。</p>
</li>
<li>
<p>最坏情况下的时间复杂度不一定高于平均情况的时间复杂度。</p>
</li>
<li>
<p>时间复杂度与所用的计算工具无关。</p>
</li>
<li>
<p>对同一个问题采用不同的算法，时间复杂度是不同的。</p>
</li>
<li>
<p>时间复杂度与采用算法所描述的语言无关。</p>
</li>
<li>
<p>算法的空间复杂与算法所处理的数据存储空间有关。</p>
</li>
<li>
<p>算法强调动态的执行过程，不同于静态的计算公式。</p>
</li>
<li>
<p>算法的优劣不取决于运行算法程序的环境。</p>
</li>
</ol>
<h3 id="_2-2-数据结构的基本概念" tabindex="-1"><a class="header-anchor" href="#_2-2-数据结构的基本概念" aria-hidden="true">#</a> <strong>2.2 数据结构的基本概念</strong></h3>
<h4 id="_2-2-1-什么是数据结构" tabindex="-1"><a class="header-anchor" href="#_2-2-1-什么是数据结构" aria-hidden="true">#</a> <strong>2.2.1 什么是数据结构</strong></h4>
<ol>
<li>
<p>数据结构是指相互有关联的数据元素的集合。</p>
</li>
<li>
<p>数据的逻辑结构可有多个存储结构，一个逻辑结构应该包含数据元素信息和数据元素之间前后件的关系</p>
</li>
<li>
<p>逻辑关系与它们所在计算机中的存储位置无关</p>
</li>
<li>
<p>常用的数据的存储结构有：顺序，链接，索引等</p>
</li>
<li>
<p>采用不同的存储结构，其数据处理的效率是不同的</p>
</li>
</ol>
<h4 id="_2-2-2-数据结构的图形表示" tabindex="-1"><a class="header-anchor" href="#_2-2-2-数据结构的图形表示" aria-hidden="true">#</a> <strong>2.2.2 数据结构的图形表示</strong></h4>
<ol>
<li>在数据结构中，没有前件的结点叫根节点，没有后件的结点叫叶子结点</li>
</ol>
<h4 id="_2-2-3-线性结构与非线性结构" tabindex="-1"><a class="header-anchor" href="#_2-2-3-线性结构与非线性结构" aria-hidden="true">#</a> <strong>2.2.3 线性结构与非线性结构</strong></h4>
<ol>
<li>
<p>数据结构分为两大类：线性结构和非线性结构</p>
</li>
<li>
<p>线性结构又称线性表</p>
</li>
<li>
<p>非空的线性结构应满足</p>
</li>
<li>
<ol>
<li>有且只有一个根结点</li>
</ol>
</li>
<li>
<p>每个结点最后有一个前件，也最多有一个后件</p>
</li>
<li>
<p>在一个线性结构中插入或删除一个结点后还是线性结构，如果插入或删除后不再是线性结构，那么这个数据结构不能称为线性结构</p>
</li>
<li>
<p>如果一个数据不是线性结构的，就称之为非线性结构</p>
</li>
<li>
<p>线性结构和非线性结构都可以使空的数据结构，按具体的运算规则来判断</p>
</li>
</ol>
<h3 id="_2-3-线性表及其顺序存储结构" tabindex="-1"><a class="header-anchor" href="#_2-3-线性表及其顺序存储结构" aria-hidden="true">#</a> <strong>2.3 线性表及其顺序存储结构</strong></h3>
<h4 id="_2-3-1-线性表的基本概念" tabindex="-1"><a class="header-anchor" href="#_2-3-1-线性表的基本概念" aria-hidden="true">#</a> <strong>2.3.1 线性表的基本概念</strong></h4>
<ol>
<li>
<p>线性表是最简单，最常用的一种数据结构</p>
</li>
<li>
<p>线性表是由n（n≥0）个数据元素组成的有限序列</p>
</li>
</ol>
<h4 id="_2-3-2-线性表的顺序存储结构" tabindex="-1"><a class="header-anchor" href="#_2-3-2-线性表的顺序存储结构" aria-hidden="true">#</a> <strong>2.3.2 线性表的顺序存储结构</strong></h4>
<ol>
<li>
<p>顺序存储结构特点</p>
</li>
<li>
<ol>
<li>线性表中所有元素所占空间是连续的，各个元素所占字节数是相同的</li>
</ol>
</li>
<li>
<p>线性表中各元素在存储空间是按逻辑顺序依次存放的</p>
</li>
<li>
<p>顺序表的各种处理：插入，删除，查找，排序，分解，合并，复制，逆转</p>
</li>
</ol>
<h4 id="_2-3-3-顺序表的插入" tabindex="-1"><a class="header-anchor" href="#_2-3-3-顺序表的插入" aria-hidden="true">#</a> <strong>2.3.3 顺序表的插入</strong></h4>
<ol>
<li>
<p>插入的过程：</p>
</li>
<li>
<ol>
<li>处理异常，当存储空间已满时为上溢错误，不能插入，算法结束</li>
</ol>
</li>
<li>
<p>当i＞n时，认为在最后一个元素之后插入</p>
</li>
<li>
<p>当i＜1时，认为在第一个元素之前插入</p>
</li>
<li>
<p>从第 i 个元素开始，直到第 n 个元素，均往后移动一个位置</p>
</li>
<li>
<p>将新元素插入到 i 个位置，并将线性表长度加1</p>
</li>
<li>
<p>插入过程最坏需要移动 n 个数据</p>
</li>
<li>
<p>删除的过程：</p>
</li>
<li>
<ol>
<li>处理异常，当线性表为空时为下溢错误，不能删除，算法结束</li>
</ol>
</li>
<li>
<p>当 i＞1 或当 i＜n 时，不能删除，算法结束</p>
</li>
<li>
<p>删除第 i 个元素</p>
</li>
<li>
<p>从第 i+1 个元素开始，直到第 n 个元素，均往前移动一个位置</p>
</li>
<li>
<p>将线性表长度减1</p>
</li>
<li>
<p>删除过程最坏需要移动 n-1 个数据</p>
</li>
</ol>
<h3 id="_2-4-栈和队列" tabindex="-1"><a class="header-anchor" href="#_2-4-栈和队列" aria-hidden="true">#</a> <strong>2.4 栈和队列</strong></h3>
<h4 id="_2-4-1-栈及其基本运算" tabindex="-1"><a class="header-anchor" href="#_2-4-1-栈及其基本运算" aria-hidden="true">#</a> <strong>2.4.1 栈及其基本运算</strong></h4>
<ol>
<li>
<p>栈是一种特殊的线性表，只不过这种线性表的插入语删除不需要移动表中其他的数据元素</p>
</li>
<li>
<p>栈是线性结构，在计算机中担任临时储存的功能</p>
</li>
<li>
<p>栈能保存数据，所以栈具有记忆作用</p>
</li>
<li>
<p>栈是限定在一端进行插入与删除的线性表。</p>
</li>
<li>
<p>在栈中，允许插入与删除的一端叫栈顶，另一端叫栈底</p>
</li>
<li>
<p>栈组织数据的原则：先进后出，后进先出</p>
</li>
<li>
<p>通常用指针 top 表示栈顶位置，用指针 bottom 表示栈底位置，栈顶指针top动态反映了栈中元素的变化情况</p>
</li>
<li>
<p>栈的基本运算：入栈，退栈，读栈顶元素</p>
</li>
<li>
<ol>
<li>入栈运算指在栈顶位置插入一个新元素，栈顶指针 top 进一</li>
</ol>
</li>
<li>
<p>退栈运算指删除栈顶元素，栈顶指针 top 退一</p>
</li>
<li>
<p>读栈顶元素指将栈顶元素赋给一个指定变量，这个运算不会删除栈顶元素，栈顶指针 top 也不会改变</p>
</li>
<li>
<p>栈内元素个数计算</p>
</li>
<li>
<ol>
<li>给定栈S（1：m），只能说明范围吗，不能确定方向，1是栈底或者m是栈底</li>
</ol>
</li>
<li>
<p>如果是非空栈，则 buttom≥1，元素个数 = | top-bottom | + 1，</p>
</li>
<li>
<p>初始状态为 top=0=bottom 或者 top=m+1=bottom，此时栈是空的</p>
</li>
<li>
<ol>
<li>当 top=0 为初始条件时，元素个数为 top 个</li>
</ol>
</li>
<li>
<p>当 top=m+1 为初始条件时，元素个数为 m-top+1 个</p>
</li>
<li>
<p>顺序栈和带链栈的区别</p>
</li>
<li>
<ol>
<li>带链栈的栈底指针，在操作过程中是有可能改变的</li>
</ol>
</li>
<li>
<p>顺序栈的栈底指针，在操作过程中是固定不变的</p>
</li>
<li>
<p>不管顺序栈还是带链栈，在操作过程中栈顶指针均是动态变化的</p>
</li>
</ol>
<h4 id="_2-4-2-队列及其基本运算" tabindex="-1"><a class="header-anchor" href="#_2-4-2-队列及其基本运算" aria-hidden="true">#</a> <strong>2.4.2 队列及其基本运算</strong></h4>
<ol>
<li>
<p>队列queue的概念：队列是指允许在一端插入，在另一端删除的线性表。</p>
</li>
<li>
<p>队列也是一种线性结构。需要加入的元素总是插入到线性表的末尾，并且又总是从线性表的头部取出元素。</p>
</li>
<li>
<ol>
<li>允许插入的一端称为队尾rear，尾指针总是指向最后被插入的元素</li>
</ol>
</li>
<li>
<p>允许删除的一端称为对头front，排头指针总是指向排头元素的前一个位置</p>
</li>
<li>
<p>队列组织数据的原则：先进先出，后进后出。入口和出口不是同一端。</p>
</li>
<li>
<ol>
<li>最先插入的元素将先能够被删除，</li>
</ol>
</li>
<li>
<p>最后插入的元素最后才能被删除。</p>
</li>
<li>
<p>在队列中，队尾指针和排头指针共同反映了队列中元素动态变化的情况。</p>
</li>
<li>
<p>队列的运算：入队运算和退队运算</p>
</li>
<li>
<ol>
<li>入队运算是往队尾插入一个元素，只涉及队尾指针变化</li>
</ol>
</li>
<li>
<p>退队运算是把排头删除一个元素，只涉及队头指针变化</p>
</li>
<li>
<p>循环队列的基本概念</p>
</li>
<li>
<ol>
<li>循环队列是线性结构，是队列的一种顺序存储结构，因为其存储空间是按顺序连续定义的。</li>
</ol>
</li>
<li>
<p>循环队列的对头指针可以大于，等于或小于队尾指针</p>
</li>
<li>
<p>循环队列Q（1：m）元素个数的计算公式：n = 尾指针 — 头指针</p>
</li>
<li>
<ol>
<li>当 n 为整数时，n 为所求</li>
</ol>
</li>
<li>
<p>当 n 为负数时，n+m 为所求</p>
</li>
<li>
<p>当 n=0 时，0 或 m 为所求</p>
</li>
</ol>
<h3 id="_2-5-线性链表" tabindex="-1"><a class="header-anchor" href="#_2-5-线性链表" aria-hidden="true">#</a> <strong>2.5 线性链表</strong></h3>
<h4 id="_2-5-1-线性链表的基本概念" tabindex="-1"><a class="header-anchor" href="#_2-5-1-线性链表的基本概念" aria-hidden="true">#</a> <strong>2.5.1 线性链表的基本概念</strong></h4>
<ol>
<li>
<p>线性链表：线性表的链式储存结构称为线性链表</p>
</li>
<li>
<p>储存空间分为：数据域，指针域</p>
</li>
<li>
<p>头指针指向线性链表第一个数据元素的结点</p>
</li>
<li>
<p>最后一个元素无后件，指针域为空，链表终止</p>
</li>
<li>
<p>存储序号不连续，存储空间中的位置关系和逻辑关系也不一致</p>
</li>
<li>
<p>线性链表指线性单链表，指针只能向后不能向前扫描</p>
</li>
<li>
<p>双向链表：有左右两个指针，可以指针可以前后查找</p>
</li>
<li>
<p>可利用栈：指带链的栈，栈也是线性表，可以采用链式储存结构</p>
</li>
<li>
<p>带链的队列：队友也是线性表，可以采用链式储存结构</p>
</li>
</ol>
<h4 id="_2-5-2-线性链表的基本运算" tabindex="-1"><a class="header-anchor" href="#_2-5-2-线性链表的基本运算" aria-hidden="true">#</a> <strong>2.5.2 线性链表的基本运算</strong></h4>
<ol>
<li>
<p>线性链表的插入：指在链式存储结构下的线性表中插入一个新元素</p>
</li>
<li>
<p>线性链表的删除：指在链式存储结构下的线性表中删除一个新元素</p>
</li>
<li>
<p>线性链表的插入和删除，不移动数据元素，只需改变结点指针</p>
</li>
</ol>
<h4 id="_2-5-3-循环链表" tabindex="-1"><a class="header-anchor" href="#_2-5-3-循环链表" aria-hidden="true">#</a> <strong>2.5.3 循环链表</strong></h4>
<ol>
<li>
<p>循环链表：增加了一个表头结点，指向第一个元素，构成环装链</p>
</li>
<li>
<p>在循环链表中，可以访问所有结点，而线性单链表只能访问后面的结点</p>
</li>
<li>
<p>循环链表的插入删除更加简单，不用考虑空链表或异常，实现了空表和非空表运算的统一</p>
</li>
</ol>
<h3 id="_2-6-树与二叉树" tabindex="-1"><a class="header-anchor" href="#_2-6-树与二叉树" aria-hidden="true">#</a> <strong>2.6 树与二叉树</strong></h3>
<h4 id="_2-6-1-树的基本概念" tabindex="-1"><a class="header-anchor" href="#_2-6-1-树的基本概念" aria-hidden="true">#</a> <strong>2.6.1 树的基本概念</strong></h4>
<ol>
<li>
<p>树是一种简单的非线性结构</p>
</li>
<li>
<p>度：指某个结点向下有几个分支，就是一个几度的结点</p>
</li>
<li>
<p>深度：树有几层，深度就为几</p>
</li>
<li>
<p>最大扇入：指一个结点的有最多的父节点</p>
</li>
<li>
<p>最大扇出：指一个结点的有最多的子节点</p>
</li>
</ol>
<h4 id="_2-6-2-二叉树及其基本性质" tabindex="-1"><a class="header-anchor" href="#_2-6-2-二叉树及其基本性质" aria-hidden="true">#</a> <strong>2.6.2 二叉树及其基本性质</strong></h4>
<ol>
<li>
<p>二叉树的概念：二叉树是一种线性结构</p>
</li>
<li>
<p>二叉树的特点：非空二叉树只有一个根节点，每个结点最多有两个子树，且分别称作该结点的左子树和右子树</p>
</li>
<li>
<p>在二叉树中，可以只有左子树没有右子树，也可以只有右子树没有左子树，</p>
</li>
</ol>
<p>若没有子树，则称该结点叫叶子结点</p>
<ol>
<li>
<p>二叉树的性质</p>
</li>
<li>
<ol>
<li>在二叉树的第n层上，最多有  2^（k-1）个结点</li>
</ol>
</li>
<li>
<p>深度为m的二叉树，最多有（2^m ）- 1 个结点</p>
</li>
<li>
<p>任意二叉树中，度为0的结点总是比度为2的结点多一个，若2度的个数加上0度的个数为偶数个，则不是二叉树结构</p>
</li>
<li>
<p>满二叉树：每一层上的结点数都达到最大值</p>
</li>
<li>
<p>完全二叉树：最后一层上，只缺少右边的若干结点，最左边至少有一个叶子结点</p>
</li>
</ol>
<h4 id="_2-6-3-二叉树的存储结构" tabindex="-1"><a class="header-anchor" href="#_2-6-3-二叉树的存储结构" aria-hidden="true">#</a> <strong>2.6.3 二叉树的存储结构</strong></h4>
<ol>
<li>二叉树通常采用链式存储结构，由数据域和指针域组成</li>
</ol>
<h4 id="_2-6-4-二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#_2-6-4-二叉树的遍历" aria-hidden="true">#</a> <strong>2.6.4 二叉树的遍历</strong></h4>
<ol>
<li>
<p>前序遍历：根（中）左右</p>
</li>
<li>
<p>中序遍历：左根（中）右</p>
</li>
<li>
<p>后序遍历：左右根（中）</p>
</li>
<li>
<p>若前序和中序遍历结果相同，说明 DLR=LDR，删除L后才可相等，故为右子树</p>
</li>
<li>
<p>若后序和中序遍历结果相同，说明 LRD=LDR，删除R后才可相等，故为左子树</p>
</li>
</ol>
<h3 id="_2-7-查找技术" tabindex="-1"><a class="header-anchor" href="#_2-7-查找技术" aria-hidden="true">#</a> <strong>2.7 查找技术</strong></h3>
<h4 id="_2-7-1-顺序查找" tabindex="-1"><a class="header-anchor" href="#_2-7-1-顺序查找" aria-hidden="true">#</a> <strong>2.7.1 顺序查找</strong></h4>
<ol>
<li>
<p>顺序查找：又称顺序搜索，指在线性表中查找指定元素，从线性表第一个元素开始，依次将线性表中的元素与被查元素进行比较</p>
</li>
<li>
<p>顺序查找的最坏情况为 n 次</p>
</li>
<li>
<p>只能采用顺序查找的情况：表中元素无序，和链式储存结构</p>
</li>
</ol>
<h4 id="_2-7-2-二分法查找" tabindex="-1"><a class="header-anchor" href="#_2-7-2-二分法查找" aria-hidden="true">#</a> <strong>2.7.2 二分法查找</strong></h4>
<ol>
<li>二分法查找：又称对分查找，只适用于顺序储存的有序表，最坏情况为log2的n</li>
</ol>
<h3 id="_2-8-排序技术" tabindex="-1"><a class="header-anchor" href="#_2-8-排序技术" aria-hidden="true">#</a> <strong>2.8 排序技术</strong></h3>
<h4 id="_2-8-1-交换类排序法" tabindex="-1"><a class="header-anchor" href="#_2-8-1-交换类排序法" aria-hidden="true">#</a> <strong>2.8.1 交换类排序法</strong></h4>
<ol>
<li>
<p>冒泡排序法</p>
</li>
<li>
<ol>
<li>概念：来回交换一次后，大的排到后面，小的排到前面，就像冒泡一样</li>
</ol>
</li>
<li>
<p>过程：从表头开始从前往后扫描，逐次比较相邻两元素大小，若逆序则交换一次位置，最大的就数就被换到最后，然后从n-1个数往前扫描，逐次比较相邻两元素大小，若逆序则交换一次位置，最小的数就被换到了开头，直到排完序。</p>
</li>
<li>
<p>冒泡排序法最坏交换次数 n（n-1）/ 2</p>
</li>
<li>
<p>快速排序法</p>
</li>
<li>
<ol>
<li>从线性表中选取一个元素，设置T，将小于T的数移到前排，大于T的数移到后面，分成了两个子表，再对子表进行重复操作，直到所有子表为空为止</li>
</ol>
</li>
<li>
<p>可以通过一次交换消除多个逆序，也产生了新的逆序。</p>
</li>
<li>
<p>快速排序法最坏情况也是 n（n-1）/ 2 ，但实际效率要高于冒泡排序法</p>
</li>
</ol>
<h4 id="_2-8-2-插入类排序法" tabindex="-1"><a class="header-anchor" href="#_2-8-2-插入类排序法" aria-hidden="true">#</a> <strong>2.8.2 插入类排序法</strong></h4>
<ol>
<li>
<p>简单插入排序法</p>
</li>
<li>
<ol>
<li>概念：指无序序列中的各元素依次插入到已经有序的线性表中</li>
</ol>
</li>
<li>
<p>过程：将第一个元素a放到变量 T 中，然后从把二个b与 T 比较，直到发现一个元素不大于 T 为止，将b插入t中</p>
</li>
<li>
<p>最坏情况为 n（n-1）/ 2</p>
</li>
<li>
<p>希尔排序法</p>
</li>
<li>
<ol>
<li>希尔排序法对简单插入排序做了较大的改进</li>
</ol>
</li>
<li>
<p>将整个无序序列分割成若干的子序列分别进行插入排序</p>
</li>
<li>
<p>最坏情况为O（n^1.5）</p>
</li>
</ol>
<h4 id="_2-8-3-选择类排序法" tabindex="-1"><a class="header-anchor" href="#_2-8-3-选择类排序法" aria-hidden="true">#</a> <strong>2.8.3 选择类排序法</strong></h4>
<ol>
<li>
<p>简单选择排序法</p>
</li>
<li>
<ol>
<li>过程：扫描整个线性表，从中选出最小的元素，将他放到表的最前面，然后对剩下的子表采用同样的方法，直到子表空为止</li>
</ol>
</li>
<li>
<p>最坏情况 n（n-1）/ 2</p>
</li>
<li>
<p>堆排序法</p>
</li>
<li>
<ol>
<li>定义：堆排序法为完全二叉树结构，且两个子结点大小等于或小于等于他们的父结点</li>
</ol>
</li>
<li>
<p>过程：不满足堆的条件时要调整堆，将根结点值与左子树右子树的结点值进行比较，将左子树右子树结点值中的大者与根结点值进行交换，直到所有子树均为堆为止</p>
</li>
<li>
<p>不适用与小规模的线性表，适用于较大规模的线性表</p>
</li>
<li>
<p>最坏情况为 （n log2n）</p>
</li>
<li>
<p>所有排序法中，其他四种算法最坏情况均为 n（n-1）/ 2，特殊的两个是，</p>
</li>
</ol>
<p>堆排序法 （n log2n），希尔排序法O（n^1.5），</p>
<p>其中时间复杂度最小的是堆排序法</p>
<hr>
<h2 id="第3章-程序设计基础" tabindex="-1"><a class="header-anchor" href="#第3章-程序设计基础" aria-hidden="true">#</a> <strong>第3章 程序设计基础</strong></h2>
<h3 id="_3-1-程序设计方法与风格" tabindex="-1"><a class="header-anchor" href="#_3-1-程序设计方法与风格" aria-hidden="true">#</a> <strong>3.1 程序设计方法与风格</strong></h3>
<ol>
<li>
<p>程序是算法与数据结构的结合</p>
</li>
<li>
<p>程序设计风格：清晰第一，效率第二</p>
</li>
<li>
<p>源程序文档化</p>
</li>
<li>
<ol>
<li>符号名的命名要有实际含义，便于理解</li>
</ol>
</li>
<li>
<p>程序注释分为序言性注释和功能性注释</p>
</li>
<li>
<p>视觉组织，使用缩进使代码层次清晰</p>
</li>
<li>
<p>数据说明方法</p>
</li>
<li>
<ol>
<li>数据说明次序规范化</li>
</ol>
</li>
<li>
<p>说明语句中变量安排有序化</p>
</li>
<li>
<p>使用注释来说明复杂数据的结构</p>
</li>
<li>
<p>语句的结构</p>
</li>
<li>
<ol>
<li>一行内只写一条语句</li>
</ol>
</li>
<li>
<p>优先考虑清晰性，清晰第一，效率第二</p>
</li>
<li>
<p>避免使用临时变量使程序可读性下降</p>
</li>
<li>
<p>避免不必要的转移</p>
</li>
<li>
<p>尽可能使用库函数</p>
</li>
<li>
<p>结构模块化，模块功能单一化</p>
</li>
<li>
<p>使用封装隐蔽信息，确保每个模块的独立性</p>
</li>
<li>
<p>输入和输出</p>
</li>
<li>
<ol>
<li>保持输入格式与输入语句的一致性</li>
</ol>
</li>
</ol>
<h3 id="_3-2-结构化程序设计" tabindex="-1"><a class="header-anchor" href="#_3-2-结构化程序设计" aria-hidden="true">#</a> <strong>3.2 结构化程序设计</strong></h3>
<h4 id="_3-2-1-结构化程序设计的原则" tabindex="-1"><a class="header-anchor" href="#_3-2-1-结构化程序设计的原则" aria-hidden="true">#</a> <strong>3.2.1 结构化程序设计的原则</strong></h4>
<ol>
<li>
<p>结构化程序设计方法主要原则：自顶向下，逐步求精，模块化，限制使用goto语句</p>
</li>
<li>
<ol>
<li>自顶向下：从最上层总目标开始设计，逐步使问题具体化</li>
</ol>
</li>
<li>
<p>逐步求精：设计一些子目标过渡，逐步细化</p>
</li>
<li>
<p>模块化：总目标再分解，把每个小目标称为一个模块</p>
</li>
<li>
<p>限制使用goto语句：可能漏过重要数据，尽量避免使用</p>
</li>
</ol>
<h4 id="_3-2-2-结构化程序的基本结构与特点" tabindex="-1"><a class="header-anchor" href="#_3-2-2-结构化程序的基本结构与特点" aria-hidden="true">#</a> <strong>3.2.2 结构化程序的基本结构与特点</strong></h4>
<ol>
<li>
<p>顺序结构：按顺序语句行的自然顺序，一条语句一条语句地执行</p>
</li>
<li>
<p>选择结构：根据条件，判断执行哪条分支</p>
</li>
<li>
<p>循环结构：根据条件，重复执行某个相同的程序段，可简化大量的程序行</p>
</li>
</ol>
<h4 id="_3-2-3-结构化程序设计原则和方法的应用" tabindex="-1"><a class="header-anchor" href="#_3-2-3-结构化程序设计原则和方法的应用" aria-hidden="true">#</a> <strong>3.2.3 结构化程序设计原则和方法的应用</strong></h4>
<ol>
<li>
<p>选用的控制结构只准有一个入口和出口</p>
</li>
<li>
<p>每个模块只有一个入口和出口</p>
</li>
<li>
<p>复杂语句使用嵌套实现</p>
</li>
<li>
<p>严格控制goto语句</p>
</li>
</ol>
<h3 id="_3-3-面向对象方法的基本概念" tabindex="-1"><a class="header-anchor" href="#_3-3-面向对象方法的基本概念" aria-hidden="true">#</a> <strong>3.3 面向对象方法的基本概念</strong></h3>
<h4 id="_3-3-1-关于面向对象方法" tabindex="-1"><a class="header-anchor" href="#_3-3-1-关于面向对象方法" aria-hidden="true">#</a> <strong>3.3.1 关于面向对象方法</strong></h4>
<ol>
<li>
<p>面向对象的方法的主要优点</p>
</li>
<li>
<ol>
<li>与人类习惯的思维方法一致：模拟现实世界中的概念而不强调算法</li>
</ol>
</li>
<li>
<p>稳定性好：需求发生变化时，只需要局部修改</p>
</li>
<li>
<p>可重用性好：对象类可以实例化实现重用，类的继承也是实现了重用</p>
</li>
<li>
<p>易于开发大型软件：把一个大型产品看成一系列本质上相互独立的小产品</p>
</li>
<li>
<p>可维护性好：体现于稳定性，容易修改，容易理解，容易测试调试</p>
</li>
</ol>
<h4 id="_3-3-2-面向对象方法的基本概念" tabindex="-1"><a class="header-anchor" href="#_3-3-2-面向对象方法的基本概念" aria-hidden="true">#</a> <strong>3.3.2 面向对象方法的基本概念</strong></h4>
<ol>
<li>
<p>对象的概念：对象是把属性和方法封装在一起构成的统一体</p>
</li>
<li>
<p>对象的特点</p>
</li>
<li>
<ol>
<li>标识唯一性：每个对象的本质不同</li>
</ol>
</li>
<li>
<p>分类性：相同属性和操作的对象可以抽象成类</p>
</li>
<li>
<p>多态性：一个操作可以使不同对象的行为</p>
</li>
<li>
<p>封装性：对象内部的结构和算法，对外不可见</p>
</li>
<li>
<p>模块独立性好：高内聚低耦合</p>
</li>
<li>
<p>类和实例</p>
</li>
<li>
<ol>
<li>类是具有共同属性、共同方法的对象的集合</li>
</ol>
</li>
<li>
<p>对象可以指一个具体的对象，也可以泛指一般对象</p>
</li>
<li>
<p>实例只能指一个具体的对象</p>
</li>
<li>
<p>消息：对象和对象间的相互合作的协助机制，叫做消息</p>
</li>
<li>
<p>继承：继承是使已有的类定义为基础建立新类的定义技术</p>
</li>
<li>
<p>多态性</p>
</li>
<li>
<ol>
<li>对象根据所接受的消息而做出的动作，同样的消息被不同的对象接收时，可导致完全不同的行为，这种现象叫做多态</li>
</ol>
</li>
<li>
<p>利用多态性，用户能够发送一般形式的消息，而将所有的现实细节都留给接收消息的对象</p>
</li>
</ol>
<hr>
<h2 id="第4章-软件工程基础" tabindex="-1"><a class="header-anchor" href="#第4章-软件工程基础" aria-hidden="true">#</a> <strong>第4章 软件工程基础</strong></h2>
<h3 id="_4-1-软件工程基本概念" tabindex="-1"><a class="header-anchor" href="#_4-1-软件工程基本概念" aria-hidden="true">#</a> <strong>4.1 软件工程基本概念</strong></h3>
<h4 id="_4-1-1-软件定义与软件特点" tabindex="-1"><a class="header-anchor" href="#_4-1-1-软件定义与软件特点" aria-hidden="true">#</a> <strong>4.1.1 软件定义与软件特点</strong></h4>
<ol>
<li>
<p>软件：包括程序、数据和相关文档的完整集合</p>
</li>
<li>
<p>程序：适合计算机执行的指令序列</p>
</li>
<li>
<p>数据：是使程序能正常操作信息的数据结构</p>
</li>
<li>
<p>文档：与程序开发维护和使用，有关的图文资料</p>
</li>
<li>
<p>软件的特点</p>
</li>
<li>
<ol>
<li>软件是一种逻辑实体</li>
</ol>
</li>
<li>
<p>软件的生产与硬件不同，它没有明显的制作过程</p>
</li>
<li>
<p>软件在运行不存在磨损、老化问题</p>
</li>
<li>
<p>软件有移植性的问题</p>
</li>
<li>
<p>软件复杂性高，成本昂贵</p>
</li>
<li>
<p>软件开发涉及诸多社会元素</p>
</li>
</ol>
<h4 id="_4-1-2-软件危机与软件工程" tabindex="-1"><a class="header-anchor" href="#_4-1-2-软件危机与软件工程" aria-hidden="true">#</a> <strong>4.1.2 软件危机与软件工程</strong></h4>
<ol>
<li>
<p>软件危机主要表现：成本、质量、生产率的问题</p>
</li>
<li>
<ol>
<li>软件需求的增长得不到满足</li>
</ol>
</li>
<li>
<p>软件质量难以保证</p>
</li>
<li>
<p>软件开发成本和进度无法控制</p>
</li>
<li>
<p>软件维护程度非常低</p>
</li>
<li>
<p>软件开发生产率跟不上硬件发展和需求的增长</p>
</li>
</ol>
<h4 id="_4-1-3-软件过程与软件生命周期" tabindex="-1"><a class="header-anchor" href="#_4-1-3-软件过程与软件生命周期" aria-hidden="true">#</a> <strong>4.1.3 软件过程与软件生命周期</strong></h4>
<ol>
<li>
<p>软件过程：把输入转化为输出的一组彼此相关的资源和活动</p>
</li>
<li>
<p>软件生命周期：从软件提出、实现、使用维护，到停运的过程</p>
</li>
<li>
<p>软件生命周期中各阶段的基本任务</p>
</li>
<li>
<ol>
<li>可行性研究与指定</li>
</ol>
</li>
<li>
<p>需求分析</p>
</li>
<li>
<p>软件设计</p>
</li>
<li>
<p>编码</p>
</li>
<li>
<p>软件测试</p>
</li>
<li>
<p>运行和维护</p>
</li>
</ol>
<h4 id="_4-1-4-软件工程的目标与原则" tabindex="-1"><a class="header-anchor" href="#_4-1-4-软件工程的目标与原则" aria-hidden="true">#</a> <strong>4.1.4 软件工程的目标与原则</strong></h4>
<ol>
<li>
<p>软件工程的目标：在给定成本、进度的前提下，开发出满足用户需求的产品</p>
</li>
<li>
<p>软件开发技术：软件开发方法学，开发过程，开发工具和软件工程环境</p>
</li>
<li>
<p>软件工程管理：软件管理学，软件工程经济学，软件心理学</p>
</li>
<li>
<ol>
<li>主要思想将工程化原则运用到软件开发过程</li>
</ol>
</li>
<li>
<p>主要包括：方法，工具，和过程</p>
</li>
<li>
<p>软件工程的原则：抽象，信息隐蔽，模块化，局部化，确定性，一致性，完备性和可验证性</p>
</li>
</ol>
<h4 id="_4-1-5-软件开发工具与软件开发环境" tabindex="-1"><a class="header-anchor" href="#_4-1-5-软件开发工具与软件开发环境" aria-hidden="true">#</a> <strong>4.1.5 软件开发工具与软件开发环境</strong></h4>
<ol>
<li>
<p>软件开发工具为软件工程提供了自动或半自动的软件支撑环境，软件开发方法的有效应用也必须得到相应工具的支持</p>
</li>
<li>
<p>软件开发环境是全面支持软件开发全过程的软件工具集合</p>
</li>
<li>
<p>计算机辅助软件工程将最大限度的降低软件开发的技术难度并提高了质量</p>
</li>
</ol>
<h3 id="_4-2-结构化分析方法" tabindex="-1"><a class="header-anchor" href="#_4-2-结构化分析方法" aria-hidden="true">#</a> <strong>4.2 结构化分析方法</strong></h3>
<h4 id="_4-2-1-需求分析与需求分析方法" tabindex="-1"><a class="header-anchor" href="#_4-2-1-需求分析与需求分析方法" aria-hidden="true">#</a> <strong>4.2.1 需求分析与需求分析方法</strong></h4>
<ol>
<li>
<p>软件需求：用户对软件的期望</p>
</li>
<li>
<p>需求分析：分析和审查已经收集到的需求</p>
</li>
<li>
<p>需求分析方法：结构化分析方法和面向对象分析方法</p>
</li>
</ol>
<h4 id="_4-2-2-结构化分析方法" tabindex="-1"><a class="header-anchor" href="#_4-2-2-结构化分析方法" aria-hidden="true">#</a> <strong>4.2.2 结构化分析方法</strong></h4>
<ol>
<li>
<p>结构化分析方法：基于各种结构化分析的常用工具，建立一种结构化规格说明的目标文档，目的是帮助用户弄清对软件的需求</p>
</li>
<li>
<p>结构化分析的常用工具</p>
</li>
<li>
<ol>
<li>数据流图：描述数据处理过程的工具，是需求理解的逻辑模型的图形表示</li>
</ol>
</li>
<li>
<p>数据字典：对所有与系统相关的数据元素的一个有组织的列表</p>
</li>
<li>
<p>判定树：找出判定条件之间的关系。根据它们构造判定树</p>
</li>
<li>
<p>判定表：加工要依赖多个逻辑条件的取值，更适合用判定表</p>
</li>
</ol>
<h4 id="_4-2-3-软件需求规格说明书" tabindex="-1"><a class="header-anchor" href="#_4-2-3-软件需求规格说明书" aria-hidden="true">#</a> <strong>4.2.3 软件需求规格说明书</strong></h4>
<ol>
<li>
<p>软件需求规格说明：是描述需求中的重要文档，是软件需求分析的最后成果</p>
</li>
<li>
<p>说明书的作用</p>
</li>
<li>
<ol>
<li>便于用户、开发人员进行理解和交流</li>
</ol>
</li>
<li>
<p>反应出用户问题的结构，可以作为软件开发工作的基础和依据</p>
</li>
<li>
<p>作为确认测试和验收的依据</p>
</li>
<li>
<p>为成本估算和编制计划进度提供基础</p>
</li>
<li>
<p>软件不断改进的基础</p>
</li>
<li>
<p>说明书的内容：重点描述软件目标，功能，性能，接口，约束条件</p>
</li>
<li>
<p>说明书的特点：确定性，无歧义性，完整性，可验证性，可修改性，可追踪性，一致性，可理解性</p>
</li>
</ol>
<h3 id="_4-3-结构化设计方法" tabindex="-1"><a class="header-anchor" href="#_4-3-结构化设计方法" aria-hidden="true">#</a> <strong>4.3 结构化设计方法</strong></h3>
<h4 id="_4-3-1-软件设计的基本概念" tabindex="-1"><a class="header-anchor" href="#_4-3-1-软件设计的基本概念" aria-hidden="true">#</a> <strong>4.3.1 软件设计的基本概念</strong></h4>
<ol>
<li>
<p>软件设计概念：把一个软件需求转换为软件表示的过程</p>
</li>
<li>
<p>软件设计基本原理：抽象，逐步求精和模块化，信息隐蔽和局部化，模块独立性</p>
</li>
<li>
<p>软件设计应做到高内聚、低耦合</p>
</li>
<li>
<ol>
<li>耦合性：是对模块间互相连接的紧密程度的度量，一个模块的耦合性越高则该模块的独立性越弱</li>
</ol>
</li>
<li>
<p>内聚性：是对一个模块内部各个元素箭彼此结合的紧密程度的度量，一个模块的内聚性越高则该模块的独立性越强</p>
</li>
<li>
<p>结构化设计方法：将软件设计成由相对独立，单一功能的模块组成的结构</p>
</li>
</ol>
<h4 id="_4-3-2-概要设计" tabindex="-1"><a class="header-anchor" href="#_4-3-2-概要设计" aria-hidden="true">#</a> <strong>4.3.2 概要设计</strong></h4>
<ol>
<li>
<p>概要设计任务</p>
</li>
<li>
<ol>
<li>设计软件系统结构</li>
</ol>
</li>
<li>
<p>数据结构及数据库设计</p>
</li>
<li>
<p>编写概要设计文档</p>
</li>
<li>
<p>概要设计文档评审</p>
</li>
<li>
<p>常用的软件结构设计工具是结构图SC，也叫程序结构图</p>
</li>
<li>
<p>面向数据流的结构化设计方法</p>
</li>
<li>
<ol>
<li>数据流类型有两种：变换型和事务型</li>
</ol>
</li>
<li>
<p>设计的准则</p>
</li>
<li>
<ol>
<li>提高模块独立性</li>
</ol>
</li>
<li>
<p>模块规模适中</p>
</li>
<li>
<p>深度、宽度、扇入、扇出适当</p>
</li>
<li>
<p>使模块的作用域在该模块的控制域内</p>
</li>
<li>
<p>应减少模块的接口和界面的复杂性</p>
</li>
<li>
<p>设计成单入口，单出口的模块</p>
</li>
<li>
<p>设计功能可预测的模块</p>
</li>
</ol>
<h4 id="_4-3-3-详细设计" tabindex="-1"><a class="header-anchor" href="#_4-3-3-详细设计" aria-hidden="true">#</a> <strong>4.3.3 详细设计</strong></h4>
<ol>
<li>
<p>详细的设计的任务是为每一个模块实现算法和局部数据结构</p>
</li>
<li>
<p>常见的过程设计工具：程序流程图、NS图、PAD图、HIPO图、判定表、PDL伪码</p>
</li>
</ol>
<h3 id="_4-4-软件测试" tabindex="-1"><a class="header-anchor" href="#_4-4-软件测试" aria-hidden="true">#</a> <strong>4.4 软件测试</strong></h3>
<h4 id="_4-4-1-软件测试的目的和定义" tabindex="-1"><a class="header-anchor" href="#_4-4-1-软件测试的目的和定义" aria-hidden="true">#</a> <strong>4.4.1 软件测试的目的和定义</strong></h4>
<ol>
<li>软件测试是为了发现错误</li>
</ol>
<h4 id="_4-4-2-软件测试的准则" tabindex="-1"><a class="header-anchor" href="#_4-4-2-软件测试的准则" aria-hidden="true">#</a> <strong>4.4.2 软件测试的准则</strong></h4>
<ol>
<li>
<p>所有测试都应追溯到需求</p>
</li>
<li>
<p>严格的测试计划</p>
</li>
<li>
<p>保存测试报告</p>
</li>
</ol>
<h4 id="_4-4-3-软件测试的方法与技术综述" tabindex="-1"><a class="header-anchor" href="#_4-4-3-软件测试的方法与技术综述" aria-hidden="true">#</a> <strong>4.4.3 软件测试的方法与技术综述</strong></h4>
<ol>
<li>
<p>静态测试：不运行的情况下，肉眼检查代码错误</p>
</li>
<li>
<p>动态测试：运行程序时，输入数据后，检查输出的结果是否符合预期</p>
</li>
<li>
<p>黑盒测试：黑盒测试也称功能测试或数据驱动测试，只能看见程序外部</p>
</li>
<li>
<ol>
<li>主要方法有等价划分法，边界值分析法，错误推测法，因果图</li>
</ol>
</li>
<li>
<p>白盒测试：白盒测试也称结构测试或逻辑驱动测试，只能看见程序内部</p>
</li>
<li>
<ol>
<li>主要方法：逻辑覆盖，基本路径测试</li>
</ol>
</li>
</ol>
<h4 id="_4-4-4-软件测试的策略" tabindex="-1"><a class="header-anchor" href="#_4-4-4-软件测试的策略" aria-hidden="true">#</a> <strong>4.4.4 软件测试的策略</strong></h4>
<ol>
<li>
<p>软件测试过程分为四个步骤：单元测试，集成测试，确认测试，系统测试</p>
</li>
<li>
<p>单元测试</p>
</li>
<li>
<ol>
<li>概念：单元测试是对模块进行正确性检验的测试</li>
</ol>
</li>
<li>
<p>依据：详细设计说明书和源程序</p>
</li>
<li>
<p>方法：白盒测试</p>
</li>
<li>
<p>集成测试</p>
</li>
<li>
<ol>
<li>概念：测试和组装软件的过程，发现与接口有关的错误</li>
</ol>
</li>
<li>
<p>依据：概要设计说明书</p>
</li>
<li>
<p>方法：增量方法组装和非增量方式组装，即逐步组装和完整组装</p>
</li>
<li>
<p>确认测试</p>
</li>
<li>
<ol>
<li>概念：验证软件的功能是否满足需求</li>
</ol>
</li>
<li>
<p>依据：需求分析规格说明书</p>
</li>
<li>
<p>方法：黑盒测试</p>
</li>
<li>
<p>系统测试</p>
</li>
<li>
<ol>
<li>概念：在模拟真实的不同的，硬件和系统的环境下，检验软件是否能正常工作</li>
</ol>
</li>
<li>
<p>依据：需求分析规格说明书</p>
</li>
</ol>
<h3 id="_4-5-程序的调试" tabindex="-1"><a class="header-anchor" href="#_4-5-程序的调试" aria-hidden="true">#</a> <strong>4.5 程序的调试</strong></h3>
<h4 id="_4-5-1-程序调试基本概念" tabindex="-1"><a class="header-anchor" href="#_4-5-1-程序调试基本概念" aria-hidden="true">#</a> <strong>4.5.1 程序调试基本概念</strong></h4>
<ol>
<li>
<p>调试的概念：在开发阶段，测试成功后，对程序进行调试</p>
</li>
<li>
<p>调试的目的：诊断和改正程序中的错误</p>
</li>
<li>
<p>调试和测试的区别：调试只在软件开发阶段，主要是改正软件错误，而测试贯穿整个软件的生命周期，主要是检查软件错误</p>
</li>
</ol>
<h4 id="_4-5-2-软件调试方法" tabindex="-1"><a class="header-anchor" href="#_4-5-2-软件调试方法" aria-hidden="true">#</a> <strong>4.5.2 软件调试方法</strong></h4>
<ol>
<li>
<p>强行排错法：设置断点，监视表达式</p>
</li>
<li>
<p>回溯法：逆向跟踪源程序代码</p>
</li>
<li>
<p>原因排除法：演绎，归纳，二分法</p>
</li>
</ol>
<hr>
<h2 id="第5章-数据库设计基础" tabindex="-1"><a class="header-anchor" href="#第5章-数据库设计基础" aria-hidden="true">#</a> <strong>第5章 数据库设计基础</strong></h2>
<h3 id="_5-1-数据库系统的基本概念" tabindex="-1"><a class="header-anchor" href="#_5-1-数据库系统的基本概念" aria-hidden="true">#</a> <strong>5.1 数据库系统的基本概念</strong></h3>
<h4 id="_5-1-1-数据、数据库、数据库管理系统" tabindex="-1"><a class="header-anchor" href="#_5-1-1-数据、数据库、数据库管理系统" aria-hidden="true">#</a> <strong>5.1.1 数据、数据库、数据库管理系统</strong></h4>
<ol>
<li>
<p>数据：是描述事物的符号记录</p>
</li>
<li>
<p>数据库：是数据的集合，具有统一的结构形式并存放在统一的存储介质内</p>
</li>
<li>
<p>数据库管理系统：是数据库的机构，是系统软件，是数据库系统的核心</p>
</li>
<li>
<ol>
<li>数据定义语言：负责数据的模式定义与数据的物理存取构建</li>
</ol>
</li>
<li>
<p>数据操纵语言：负责数据的操纵，包括查增删改</p>
</li>
<li>
<p>数据控制语言：负责数据完整性、安全性检查，并发和故障恢复</p>
</li>
<li>
<p>数据库管理员：是数据库的专业管理员</p>
</li>
<li>
<p>数据库系统：由五部分组成；数据库，数据库管理系统，数据库管理人员，硬件平台，软件平台</p>
</li>
<li>
<p>数据库应用系统：由三部分组成；数据库系统，应用软件，应用界面；是利用数据库系统进行只针对某一领域的应用开发</p>
</li>
</ol>
<h4 id="_5-1-2-数据库系统的发展" tabindex="-1"><a class="header-anchor" href="#_5-1-2-数据库系统的发展" aria-hidden="true">#</a> <strong>5.1.2 数据库系统的发展</strong></h4>
<ol>
<li>
<p>数据库的管理发展的三个阶段</p>
</li>
<li>
<ol>
<li>人工管理</li>
</ol>
</li>
<li>
<p>文件系统</p>
</li>
<li>
<p>数据库系统</p>
</li>
</ol>
<h4 id="_5-1-3-数据库系统的基本特点" tabindex="-1"><a class="header-anchor" href="#_5-1-3-数据库系统的基本特点" aria-hidden="true">#</a> <strong>5.1.3 数据库系统的基本特点</strong></h4>
<ol>
<li>
<p>数据的集成性</p>
</li>
<li>
<p>数据的高共享性与低冗余性</p>
</li>
<li>
<p>数据独立性：主要表现在物理独立性和逻辑独立性上</p>
</li>
<li>
<ol>
<li>物理独立性：物理结构的改变，不影响逻辑结构</li>
</ol>
</li>
<li>
<p>逻辑独立性：修改数据库逻辑结果，不需要修改应用程序</p>
</li>
<li>
<p>数据统一管理与控制：完整性检查，安全性保护，并发控制</p>
</li>
</ol>
<h4 id="_5-1-4-数据库系统的内部结构体系" tabindex="-1"><a class="header-anchor" href="#_5-1-4-数据库系统的内部结构体系" aria-hidden="true">#</a> <strong>5.1.4 数据库系统的内部结构体系</strong></h4>
<ol>
<li>
<p>数据库的三级模式：概念模式，外模式（用户模式），内模式（物理模式）</p>
</li>
<li>
<p>数据库的两级映射：外模式到概念模式的映射，概念模式到内模式的映射</p>
</li>
<li>
<p>概念模式：是数据库系统中全局数据逻辑结构的描述</p>
</li>
<li>
<p>外模式：是用户所见到的数据模式</p>
</li>
<li>
<p>内模式：它给出了数据库物理存储结构和物理存取方法</p>
</li>
<li>
<p>外模式到概念模式的映射：给出了数据的逻辑结构和物理存储结构的对应关系</p>
</li>
<li>
<p>概念模式到内模式的映射：给出了外模式与概念模式的对应关系，一个概念模式可以定义多个外模式</p>
</li>
</ol>
<h3 id="_5-2-数据模型" tabindex="-1"><a class="header-anchor" href="#_5-2-数据模型" aria-hidden="true">#</a> <strong>5.2 数据模型</strong></h3>
<h4 id="_5-2-1-数据模型的基本概念" tabindex="-1"><a class="header-anchor" href="#_5-2-1-数据模型的基本概念" aria-hidden="true">#</a> <strong>5.2.1 数据模型的基本概念</strong></h4>
<ol>
<li>
<p>数据是现实世界符号的抽象，数据模式是数据特征的抽象，是数据库设计的核心</p>
</li>
<li>
<p>数据模型所描述的内容有三部分，数据结构、数据操作、数据约束</p>
</li>
<li>
<p>数据模型按不同的应用层次分成三种类型</p>
</li>
<li>
<ol>
<li>概念数据模型：简称概念模型，面相最终用户的模型</li>
</ol>
</li>
<li>
<p>逻辑数据模型：简称数据模型，面向数据库系统的模型</p>
</li>
<li>
<p>物理数据模型：简称物理模型，面向计算机物理表示的模型</p>
</li>
</ol>
<h4 id="_5-2-2-e-r模型" tabindex="-1"><a class="header-anchor" href="#_5-2-2-e-r模型" aria-hidden="true">#</a> <strong>5.2.2 E-R模型</strong></h4>
<ol>
<li>
<p>E-R模型是概念数据模型，将现实世界的要求转化为实体，属性，联系等基本概念，用一种图直观的表示出来</p>
</li>
<li>
<ol>
<li>实体：现实世界中的事物抽象而成</li>
</ol>
</li>
<li>
<p>属性：事物的特性用属性来表示</p>
</li>
<li>
<p>联系：一对多，多对多，一对一</p>
</li>
<li>
<p>图示法：</p>
</li>
<li>
<ol>
<li>方框：实体集表示法</li>
</ol>
</li>
<li>
<p>圆：属性表示法</p>
</li>
<li>
<p>菱形：联系表示法</p>
</li>
</ol>
<h4 id="_5-2-3-层次模型" tabindex="-1"><a class="header-anchor" href="#_5-2-3-层次模型" aria-hidden="true">#</a> <strong>5.2.3 层次模型</strong></h4>
<ol>
<li>层次模型的基本结构是树形结构</li>
</ol>
<h4 id="_5-2-4-网状模型" tabindex="-1"><a class="header-anchor" href="#_5-2-4-网状模型" aria-hidden="true">#</a> <strong>5.2.4 网状模型</strong></h4>
<ol>
<li>网状模型的基本结构是简单二级树，又叫系</li>
</ol>
<h4 id="_5-2-5-关系模型" tabindex="-1"><a class="header-anchor" href="#_5-2-5-关系模型" aria-hidden="true">#</a> <strong>5.2.5 关系模型</strong></h4>
<ol>
<li>
<p>关系模型用二维表表示，简称表</p>
</li>
<li>
<p>主键：在表A中，由一个或一组属性值组成，具有唯一标识性</p>
</li>
<li>
<p>外键：在表B中是主键，但是在表A中重复出现，所以是外键</p>
</li>
<li>
<p>关系操纵：是关系模型的数据操纵，有增删改查四种操作</p>
</li>
<li>
<p>关系中的数据约束</p>
</li>
<li>
<ol>
<li>实体完整性约束：主键中的属性值不能为空</li>
</ol>
</li>
<li>
<p>参照完整性约束：不允许引用不存在的元组</p>
</li>
<li>
<p>用户定义的完整性：由用户自己手动设置的约束</p>
</li>
</ol>
<h3 id="_5-3-关系代数" tabindex="-1"><a class="header-anchor" href="#_5-3-关系代数" aria-hidden="true">#</a> <strong>5.3 关系代数</strong></h3>
<ol>
<li>
<p>关系模型的特有运算</p>
</li>
<li>
<ol>
<li>投影运算：选列，从一个表中选出某些列作为新表</li>
</ol>
</li>
<li>
<p>选择运算：选行，从一个表中选出某些行作为新表</p>
</li>
<li>
<p>连接运算：选出符合条件的行组成新表</p>
</li>
<li>
<p>自然连接运算：没有任何条件的连接，选出相等的即可</p>
</li>
<li>
<p>关系模型的代数运算</p>
</li>
<li>
<ol>
<li>交集运算：选出两个表的相同行，作为新表</li>
</ol>
</li>
<li>
<p>并集运算：选出两个表不重复的行，作为新表</p>
</li>
<li>
<p>差集运算：一个表减去另一个表</p>
</li>
<li>
<p>关系模型的扩充运算</p>
</li>
<li>
<ol>
<li>笛卡尔运算：所有的排列组合</li>
</ol>
</li>
<li>
<p>除运算：笛卡尔运算的逆运算</p>
</li>
</ol>
<h3 id="_5-4-数据库设计与管理" tabindex="-1"><a class="header-anchor" href="#_5-4-数据库设计与管理" aria-hidden="true">#</a> <strong>5.4 数据库设计与管理</strong></h3>
<h4 id="_5-4-1-数据库设计概述" tabindex="-1"><a class="header-anchor" href="#_5-4-1-数据库设计概述" aria-hidden="true">#</a> <strong>5.4.1 数据库设计概述</strong></h4>
<ol>
<li>
<p>数据库设计采用生命周期：需求分析阶段，概念设计阶段，逻辑设计阶段，物理设计阶段，还有编码测试运行阶段</p>
</li>
<li>
<p>在生命周期的前四个阶段，重点以数据结构与模型的设计为主线</p>
</li>
</ol>
<h4 id="_5-4-2-数据库设计的需求分析" tabindex="-1"><a class="header-anchor" href="#_5-4-2-数据库设计的需求分析" aria-hidden="true">#</a> <strong>5.4.2 数据库设计的需求分析</strong></h4>
<ol>
<li>
<p>调查用户需求：信息要求、处理要求、安全性和完整性要求</p>
</li>
<li>
<p>用数据流图表达数据处理过程的关系，数据字典对数据详尽描述</p>
</li>
<li>
<p>对数据库来说，数据字典是进行需求分析的主要成果</p>
</li>
</ol>
<h4 id="_5-4-3-数据库概念设计" tabindex="-1"><a class="header-anchor" href="#_5-4-3-数据库概念设计" aria-hidden="true">#</a> <strong>5.4.3 数据库概念设计</strong></h4>
<ol>
<li>
<p>数据库概念设计的目的是建立一个数据的抽象模型，有两种方法：</p>
</li>
<li>
<ol>
<li>集中式模式设计法：强调统一与一致，适合小型项目</li>
</ol>
</li>
<li>
<p>视图集成设计法：更好反应需求，适合大型项目</p>
</li>
</ol>
<h4 id="_5-4-4-数据库的逻辑设计" tabindex="-1"><a class="header-anchor" href="#_5-4-4-数据库的逻辑设计" aria-hidden="true">#</a> <strong>5.4.4 数据库的逻辑设计</strong></h4>
<ol>
<li>从E-R图转成成表格</li>
</ol>
<h4 id="_5-4-5-数据库的物理设计" tabindex="-1"><a class="header-anchor" href="#_5-4-5-数据库的物理设计" aria-hidden="true">#</a> <strong>5.4.5 数据库的物理设计</strong></h4>
<ol>
<li>
<p>主要目标：对数据库内部物理结构作调整并选择合理的存取路径，以提高数据库访问速度及有效利用存储空间</p>
</li>
<li>
<p>用户可设计：索引设计，集簇设计，分区设计</p>
</li>
</ol>
<h4 id="_5-4-6-数据库管理" tabindex="-1"><a class="header-anchor" href="#_5-4-6-数据库管理" aria-hidden="true">#</a> <strong>5.4.6 数据库管理</strong></h4>
<ol>
<li>
<p>数据库的建立：数据模式建立和数据加载</p>
</li>
<li>
<p>数据库的调整：调整索引与集簇，调整关系模式与视图，调整分区与缓冲区</p>
</li>
<li>
<p>数据库的重组：重新调整存储空间，提升性能</p>
</li>
<li>
<p>数据库安全性控制与完整性控制：保证数据不受破坏，取得完整性控制</p>
</li>
<li>
<p>数据库的故障恢复：数据破坏后及时修复</p>
</li>
<li>
<p>数据库监控：随时监控数据库的动态变化</p>
</li>
</ol>
</div></template>
