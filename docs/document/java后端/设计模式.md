## 第1章 七大设计原则

### 1.1 开闭原则

开闭原则就是说对扩展开放，对修改关闭。

当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。



### 1.2 依赖倒置原则

针对接口编程，依赖于抽象而不依赖于具体。

高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象



### 1.3 单一职责原则

一个类只负责一个功能领域中相应的职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。



### 1.4 接口隔离原则

使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思。



### 1.5 迪米特法则

一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。



### 1.6 里氏替换原则

子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。



### 1.7 合成复用原则

合成复用原则，要求在软件复用时，要先尽量使用组合或者聚合等关联关系实现，其次才考虑使用继承。也就是在一个新对象里通过关联的方式使用已有对象的一些方法和功能。



### 1.8 总结

| 设计原则     | 归纳                                                         | 目的                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------ |
| 开闭原则     | 对扩展开放，对修改关闭                                       | 降低维护带来的新风险                       |
| 依赖倒置原则 | 高层不应该依赖低层，要面向接口编程                           | 更利于代码结构的升级扩展                   |
| 单一职责原则 | 一个类只干一件事，实现类要单一                               | 便于理解，提高代码的可读性                 |
| 接口隔离原则 | 一个接口只干一件事，接口要精简单一                           | 功能解耦，高聚合、低耦合                   |
| 迪米特法则   | 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 | 只和朋友交流，不和陌生人说话，减少代码臃肿 |
| 里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥                               |
| 合成复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承             | 降低代码耦合                               |



### 1.9 常用的几种设计模式

单例模式

工厂模式



生产者/消费者模式

代理模式

适配器模式

装饰者模式

观察者模式







## 第2章 创建型设计模式



创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。

除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。



### 2.1 简单工厂模式

#### 2.1.1 简单工厂模式的定义和特点

工厂模式的定义：

定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。

简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。

“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。





#### 2.1.2 简单工厂模式的优点和缺点

优点：

1. 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
2. 客户端无需知道所创建具体产品的类名，只需知道参数即可。
3. 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。



缺点：

1. 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。
2. 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度
3. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
4. 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。





#### 2.1.3 简单工厂模式的应用场景

对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。





#### 2.1.4 简单工厂模式的结构与实现

简单工厂模式的主要角色如下：

- 简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
- 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
- 具体产品（ConcreteProduct）：是简单工厂模式的创建目标。



![简单工厂模式的结构图](http://c.biancheng.net/uploads/allimg/200908/5-200ZQ64244445.png)



```java
package 工厂模式.简单工厂;

//美式咖啡
public class AmCoffee extends Coffee {

    @Override
    public String getName() {
        return "美式咖啡";
    }
}

```

```java
package 工厂模式.简单工厂;

public class Client {
    public static void main(String[] args) {
        CoffeeStore coffeeStore = new CoffeeStore();
        Coffee coffee = coffeeStore.orderCoffee("latte");
        System.out.println(coffee.getName());
    }
}
```

```java
package 工厂模式.简单工厂;


//抽象类
public abstract class Coffee {
    public abstract String getName();

    public void addSuager(){
        System.out.println("加糖");

    }

    public void addMilk(){
        System.out.println("加奶");
    }


}
```

```java
package 工厂模式.简单工厂;

//import 工厂模式.前置案例.AmCoffee;

//咖啡商店
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        SimpleCoffeeFactory factory = new SimpleCoffeeFactory();
        Coffee coffee = factory.createCoffee(type);


        //加配料
        coffee.addMilk();
        coffee.addSuager();
        return coffee;
    }
}
```

```java
package 工厂模式.简单工厂;

//拿铁咖啡
public class LatteCoffee extends Coffee {
    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}
```

```java
package 工厂模式.简单工厂;


public class SimpleCoffeeFactory {

    public Coffee createCoffee(String type){
        Coffee coffee = null;
        if("am".equals(type)){
            coffee = new AmCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else {
            throw new RuntimeException("没有该咖啡");
        }

        return coffee;

    }
}
```





#### 2.1.5 简单工厂模式的扩展







### 2.3 工厂方法模式

#### 2.3.1 工厂方法模式的定义和特点

“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。



#### 2.3.2 工厂方法模式的优点和缺点

###### 优点：

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
- 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
- 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。



###### 缺点：

- 类的个数容易过多，增加复杂度
- 增加了系统的抽象性和理解难度
- 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。



#### 2.3.3 工厂方法模式的应用场景

- 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
- 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
- 客户不关心创建产品的细节，只关心产品的品牌



#### 2.3.4 工厂方法模式的结构与实现

###### 工厂方法模式的主要角色如下。

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

```java
package 工厂模式.工厂方法;


//import 工厂模式..Coffee;

//美式咖啡
public class AmCoffee extends Coffee {

    @Override
    public String getName() {
        return "美式咖啡";
    }
}
```

```java
package 工厂模式.工厂方法;

// 美式咖啡工厂对象
public class AmCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new AmCoffee();
    }
}
```

```java
package 工厂模式.工厂方法;

public class Client {
    public static void main(String[] args) {
        CoffeeStore coffeeStore = new CoffeeStore();
        CoffeeFactory coffeeFactory = new LatteCoffeeFactory();

        coffeeStore.setFactory(coffeeFactory);
        Coffee coffee = coffeeStore.orderCoffee();
        System.out.println(coffee.getName());

                //插件
    }
}
```

```java
package 工厂模式.工厂方法;


//抽象类
public abstract class Coffee {
    public abstract String getName();

    public void addSuager(){
        System.out.println("加糖");

    }

    public void addMilk(){
        System.out.println("加奶");
    }


}
```

```java
package 工厂模式.工厂方法;

// 抽象工厂
public interface CoffeeFactory {
    Coffee createCoffee();

}
```

```java
package 工厂模式.工厂方法;


//咖啡商店
public class CoffeeStore {
    private CoffeeFactory coffeeFactory;
    public void setFactory(CoffeeFactory coffeeFactory) {
            this.coffeeFactory = coffeeFactory;
    }

    public Coffee orderCoffee(){
        Coffee coffee = coffeeFactory.createCoffee();
        coffee.addMilk();
        coffee.addSuager();
        return coffee;
    }
}
```

```java
package 工厂模式.工厂方法;

//拿铁咖啡
public class LatteCoffee extends Coffee {
    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}
```

```java
package 工厂模式.工厂方法;

//拿铁咖啡工厂
public class LatteCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}
```





### 2.4 抽象工厂模式

#### 2.4.1 抽象工厂模式的定义和特点

###### 抽象工厂（AbstractFactory）模式的定义：

是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。



#### 2.4.2 抽象工厂模式的优点和缺点

###### 优点

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
- 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。



###### 缺点

当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。



#### 2.4.3 抽象工厂模式的应用场景和实例

###### 抽象工厂模式通常适用于以下场景：

1. 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
2. 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
3. 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。



###### 抽象工厂模式的应用实例

分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。

本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。

对马类、牛类、蔬菜类和水果类等具体产品类，由于要显示它们的图像，所以它们的构造函数中用到了 JPanel、JLabel 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。







#### 2.4.4 抽象工厂模式的结构与实现

模式的结构

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
2. 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。



```java
package 工厂模式.抽象工厂;


//import 工厂模式..Coffee;

//美式咖啡
public class AmCoffee extends Coffee {

    @Override
    public String getName() {
        return "美式咖啡";
    }
}
```

```java
package 工厂模式.抽象工厂;

//美式风味甜品工厂
public class AmericanDessertFactory implements DessertFactory{


    //美式咖啡
    @Override
    public Coffee createCoffee() {
        return new AmCoffee();
    }


    //美式 抹茶慕斯
    @Override
    public Dessert createDessert() {
        return new MatchaMousse();
    }
}
```

```java
package 工厂模式.抽象工厂;

public class Client {
    public static void main(String[] args) {
        ItalyDessertFactory italyDessertFactory = new ItalyDessertFactory();
        Coffee coffee = italyDessertFactory.createCoffee();
        Dessert dessert = italyDessertFactory.createDessert();
        System.out.println(coffee.getName());
        dessert.show();
    }
}
```

```java
package 工厂模式.抽象工厂;


//抽象类
public abstract class Coffee {
    public abstract String getName();

    public void addSuager(){
        System.out.println("加糖");

    }

    public void addMilk(){
        System.out.println("加奶");
    }


}
```

```java
package 工厂模式.抽象工厂;


//甜品类
public abstract class Dessert {
    public abstract void show();
}
```

```java
package 工厂模式.抽象工厂;


//
public interface DessertFactory {

    //生产咖啡
    Coffee createCoffee();

    //生产甜品
    Dessert createDessert();


}
```

```java
package 工厂模式.抽象工厂;


//意大利风味工厂
public class ItalyDessertFactory implements DessertFactory{

    //拿铁咖啡
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }


    //提拉米苏
    @Override
    public Dessert createDessert() {
        return new Trimisu();
    }
}
```

```java
package 工厂模式.抽象工厂;

//拿铁咖啡
public class LatteCoffee extends Coffee {
    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}
```

```java
package 工厂模式.抽象工厂;


//抹茶慕斯类
public class MatchaMousse extends Dessert{
    @Override
    public void show() {
        System.out.println("抹茶慕斯");
    }
}
```

```java
package 工厂模式.抽象工厂;

//提拉米苏类
public class Trimisu extends Dessert{
    @Override
    public void show() {
        System.out.println("提拉米苏 ");
    }
}
```











#### 2.4.5 抽象工厂模式的扩展

抽象工厂模式的扩展有一定的“开闭原则”倾斜性：

1. 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
2. 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。


另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。





### 2.5 单例模式

#### 2.5.1 单例模式的定义

指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。



#### 2.5.2 单例模式的特点

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点。



#### 2.5.3 单例模式的优点和缺点

单例模式的优点：

- 单例模式可以保证内存里只有一个实例，减少了内存的开销。
- 可以避免对资源的多重占用。
- 单例模式设置全局访问点，可以优化和共享资源的访问。


单例模式的缺点：

- 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
- 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。



#### 2.5.4 单例模式的应用场景

- 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
- 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
- 频繁访问数据库或文件的对象。
- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。



#### 2.5.5 单例模式的结构与实现

##### 懒汉式单例结构

该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。

```java
package 单例模式.demo2;

// 单例模式 懒汉式1
public class Slob {
    // 私有方法
    private Slob(){

    }

    // 声明变量
    private static Slob instance;

    // 对外访问 处理线程安全问题
    public static synchronized Slob getInstance() {

        //判断是否存在 如果存在直接返回
        if(instance == null) {
            instance = new Slob();
        }

        return instance;
    }

}

```



```java
package 单例模式.demo2;


public class Client {

    public static void main(String[] args) {

        //获取两次饿汉式对象
        Slob instance = Slob.getInstance();
        Slob instance1 = Slob.getInstance();

        //判断是否相同 同一个内存地址 也是同一个对象
        System.out.println(instance  == instance1);

    }
}
```



##### 懒汉式单例结构 双重检查锁

```java
package 单例模式.demo3;


// 单例模式 懒汉式 双重检查锁实现 (推荐)
// 因为大部分都是读操作 没必要加上同步锁



public class Singleton {

    //私有构造方法
    private Singleton() {

    }

    //声明变量

    //在多线程模式下 jvm的指令重排序 使得用该方法可能会有空指针异常
    //通过加上 volatile 关键字保证有序
    private static volatile Singleton instance ;

    //对外提供访问方式 不在方法上加锁了
    public static Singleton getInstance() {
        //判断是否为空
        if(instance == null ) {

            synchronized (Singleton.class) {

                if(instance == null ) {
                    instance = new Singleton();
                }
            }

        }
        return instance;
    }

}

```



```java
package 单例模式.demo3;


public class Client {
    public static void main(String[] args) {
        Singleton instance  = Singleton.getInstance();
        Singleton instance1  = Singleton.getInstance();

        System.out.println(instance == instance1);

    }
}

```



##### 懒汉式单例结构  静态内部类

```java
package 单例模式.demo4;


// 单例模式 懒汉式 静态内部类实现
public class Singleton {
    //私有方法
    private Singleton(){};

    //内部类
    // 在没有锁的情况下 保证了多线程的线程安全
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();

    }

    //对外访问
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

}

```



```java
package 单例模式.demo4;

public class Client {

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance1 = Singleton.getInstance();

        System.out.println(instance == instance1);

    }
}

```



懒汉式单例模式 枚举

```java
package 单例模式.demo5;

//单例模式 枚举实现
// 是饿汉模式 也是唯一一种不会被破坏的单利实现模式

public enum Singleton {
    INSTANCE;

}

```



```java
package 单例模式.demo5;


public class Client {
    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        Singleton instance1 = Singleton.INSTANCE;

        System.out.println(instance == instance1);
    }
}

```



##### 序列化破坏单例模式

```java
package 单例模式.demo6;


//demo6 演示序列化破坏单例模式 静态内部类的例子

import java.io.Serializable;

public class Singleton implements Serializable {

    private Singleton(){};

    //静态内部类的例子
    private static class SingletonHolder{
        private static final Singleton INSTANCE = new Singleton();

    }


    //
    public static Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }


    //使用该方法可以解决破坏单例的问题
    //反序列化的时候自动调用该方法
    // readObject底层原理实现 判断是否有该方法 有则调用
    public Object readResolve() {
        return SingletonHolder.INSTANCE;
    }



}



```

```java
package 单例模式.demo6;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class Client {
    public static void main(String[] args) throws Exception{
        //写入对象
//        writeObject2File();

        //读取两次对象 打印
        readObjectFromFile();
        readObjectFromFile();

    }

    //向文件中写数据(对象)
    public static void readObjectFromFile() throws Exception{
        //创建对象输入流
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("/Users/wangle/a.txt"));


        //读取对象
        Singleton instance = (Singleton) ois.readObject();
        System.out.println(instance);

        //释放资源
        ois.close();

    }



    //从文件中读数据(对象)
    public static void writeObject2File() throws Exception{
        //获取对象
        Singleton instance = Singleton.getInstance();

        //创建对象输出流 /Users/wangle
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("/Users/wangle/a.txt"));

        //写对象
        oos.writeObject(instance);

        //释放资源
        oos.close();
    }
}

```



##### 反射破坏单例模式

```java
package 单例模式.demo7;



//demo7 演示反射破坏单例模式


public class Singleton {

    //静态变量所有线程共享
    private static boolean flag = false;

    private Singleton(){

        synchronized (Singleton.class) {

            //判断flag是否为true
            if(flag) {
                throw new RuntimeException("不能创建多个对象");
            }

            flag = true;
        }
    };

    //静态内部类的例子
    private static class SingletonHolder{
        private static final Singleton INSTANCE = new Singleton();

    }


    //
    public static Singleton getInstance(){
        return Singleton.SingletonHolder.INSTANCE;
    }



}



```



```java
package 单例模式.demo7;

import java.lang.reflect.Constructor;

public class Client {
    public static void main(String[] args) throws  Exception{
        //获取字节码对象
        Class clazz = Singleton.class;

        //获取无参构造方法对象
        Constructor cons = clazz.getDeclaredConstructor();

        //取消访问检查
        cons.setAccessible(true);

        //创建对象
        Singleton s1 = (Singleton) cons.newInstance();
        Singleton s2 = (Singleton) cons.newInstance();

        System.out.println(s1 == s2 );

    }
}

```







##### runtime单例模式

```java
package 单例模式.demo8;


import java.io.IOException;
import java.io.InputStream;

//demo8 runtime源码 是单例设计模式
public class RuntimeDemo {
    public static void main(String[] args) throws IOException {
        //获取 runtime类对象
        Runtime runtime = Runtime.getRuntime();

        //调用exec方法
        Process process = runtime.exec("ifconfig");

        //获取输入流
        InputStream is = process.getInputStream();
        byte[] arr = new byte[1024 * 1024 * 100];

        //读取数据
        int len = is.read(arr);

        //将字节数组转为字符串输出到控制台
        System.out.println(new String(arr,0,len,"GBK"));

    }
}

```





##### 饿汉式单例结构

该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。

```java
package 单例模式.demo1;


//单例模式  饿汉式

public class hungry {

    //私有构造方法
    private hungry() {

    }

    //创建本类对象
    private static hungry instance = new hungry();


    //提供外界的访问方法
    public static hungry getInstance() {
        return instance;
    }
}
```



```java
package 单例模式.demo1;

//测试类
public class Client {

    public static void main(String[] args) {

        //获取两次饿汉式对象
        hungry instance = hungry.getInstance();
        hungry instance1 = hungry.getInstance();

        //判断是否相同 同一个内存地址 也是同一个对象
        System.out.println(instance  == instance1);
    }
}

```







##### 单例模式的应用实例

用懒汉式单例模式模拟产生美国当今总统对象。

```java
public class SingletonLazy {
    public static void main(String[] args) {
        President zt1 = President.getInstance();
        zt1.getName();    //输出总统的名字
        President zt2 = President.getInstance();
        zt2.getName();    //输出总统的名字
        if (zt1 == zt2) {
            System.out.println("他们是同一人！");
        } else {
            System.out.println("他们不是同一人！");
        }
    }
}
class President {
    private static volatile President instance = null;    //保证instance在所有线程中同步
    //private避免类在外部被实例化
    private President() {
        System.out.println("产生一个总统！");
    }
    public static synchronized President getInstance() {
        //在getInstance方法上加同步
        if (instance == null) {
            instance = new President();
        } else {
            System.out.println("已经有一个总统，不能产生新总统！");
        }
        return instance;
    }
    public void getName() {
        System.out.println("我是美国总统：特朗普。");
    }
}
```





#### 2.5.6 单例模式的扩展

单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取





### 2.6 原型模式

#### 2.6.1 原型模式的定义和特点

###### 原型模式的定义

用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。





#### 2.6.2 原型模式的优点和缺点

###### 原型模式的优点：

- Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
- 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。



###### 原型模式的缺点：

- 需要为每一个类都配置一个 clone 方法
- clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。



#### 2.6.3 原型模式的应用场景

原型模式通常适用于以下场景。

- 对象之间相同或相似，即只是个别的几个属性不同的时候。
- 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
- 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。



#### 2.6.4 原型模式的结构与实现

###### 原型模式的克隆分为浅克隆和深克隆。

- 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
- 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。



```java
package 原型模式;

import java.io.Serializable;

public class Citation implements Cloneable, Serializable {
//    private String name;
//
//    public void setName(String name) {
//        this.name = name;
//    }
//
    public void show() {
        System.out.println(stu.getName() + ": " + "同学非常优秀");

    }
    private Student stu;
    public Student getStu() {
        return stu;

    }

    public void setStu(Student stu) {
        this.stu = stu;

    }




    @Override
    public Citation clone() throws CloneNotSupportedException {
//        System.out.println("原型复制成功");
        return (Citation) super.clone();
    }
}

```

```java
package 原型模式;

import java.io.*;


//深拷贝版本
public class CitationDeepTest {

    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException {
        Citation citation = new Citation();

        Student stu = new Student();
        stu.setName("张三");
        citation.setStu(stu);

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("/Users/wangle/test/a.txt"));
        oos.writeObject(citation);
        oos.close();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("/Users/wangle/test/a.txt"));
        Citation citation1 = (Citation) ois.readObject();

        ois.close();
        Student stu1 = citation1.getStu();
        stu1.setName("李四");

        citation.show();
        citation1.show();
    }

}

```

```java
package 原型模式;


// 浅克隆版
public class CitationTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        Citation citation = new Citation();

        Student stu = new Student();
        stu.setName("张三");
        citation.setStu(stu);


        Citation citation2 = citation.clone();


        // 浅克隆 被克隆的对象与原对象完全相同,除了基本类型以外,
        // 被克隆对象的其他引用类型的对象的内存地址与原型相同
        // 即被克隆对象除了基本数据类型 直接引用了原对象的内存地址
        // 修改了被克隆对象身上的引用类型的属性 原对象身上的属性也会改变

        // 深克隆 被克隆对象的所有数据类型都是新的内存地址
        // 修改被克隆对象身上的引用类型的属性时, 原对象不受任何影响
        citation2.getStu().setName("李四");


        citation.show();
        citation2.show();
    }
}

```

```java
package 原型模式;

public class client {
    public static void main(String[] args) throws CloneNotSupportedException {
        Realizetype realType = new Realizetype ();

        Realizetype clone = realType.clone  ();
        System.out.println("原型对象和克隆对象是否是同一个对象");
        System.out.println(realType == clone);

    }
}

```

```java
package 原型模式;

public class Realizetype implements Cloneable  {
    public void realizetype() {
        System.out.println("原型创建完成");
    }

    @Override
    protected Realizetype clone() throws CloneNotSupportedException {
        System.out.println("原型复制成功");
        return (Realizetype) super.clone();
    }
}

```

```java
package 原型模式;

import java.io.Serializable;

public class Student implements Serializable {
    private String name;
    public String getName() {
        return name;

    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}

```











### 2.7 建造者模式

#### 2.7.1 建造者模式的定义和特点



#### 2.7.2 建造者模式的优点和缺点



#### 2.7.3 建造者模式的应用场景



#### 2.7.4 建造者模式的结构与实现

```java
package 建造者模式;

// 产品对象
public class Bike {
    private String seat;

    private String frame;

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }
}

```

```java
package 建造者模式;

// 抽象建造者
public abstract class Builder {
    protected Bike bike = new Bike();

    public abstract void buildFrame();
    public abstract void buildSeat();

    public abstract Bike creatBike();

}
```

```java
package 建造者模式;

//创建复杂对象
// 优点 稳定 容易拓展
public class Client {
    public static void main(String[] args) {
        //创建指挥者
        Director director = new Director(new MobaiBuilder());

        Bike bike = director.construct();

        System.out.println(bike.getFrame());
        System.out.println(bike.getSeat());

    }
}

```

```java
package 建造者模式;

// 指挥者
public class Director {
    private Builder builder;

    public Director (Builder builder) {
        this.builder = builder;
    }

    //组装操作
    public Bike construct(){
        builder.buildFrame();
        builder.buildSeat();
        return builder.creatBike();
    }
}

```

```java
package 建造者模式;


// 具体建造者 摩拜单车
public class MobaiBuilder extends Builder{
    @Override
    public void buildFrame() {
        bike.setFrame("碳纤维车架");

    }

    @Override
    public void buildSeat() {
        bike.setSeat("真皮座椅");

    }

    @Override
    public Bike creatBike() {
        return bike;
    }
}

```

```java
package 建造者模式;

// ofo单车建造者
public class OfoBuilder extends Builder{
    @Override
    public void buildFrame() {
        bike.setFrame("铝合金车架");
    }

    @Override
    public void buildSeat() {
        bike.setSeat("橡胶车座");
    }

    @Override
    public Bike creatBike() {
        return bike;
    }
}

```







#### 2.7.5 建造者模式的扩展









## 第3章 行为型设计模式

### 3.1 模板方法模式

```java
package org.example.行为型模式.模板方法模式;

public abstract class AbstractClass {
    public void pourOil() {
        System.out.println("倒油");
    }

    public void hotOil(){
        System.out.println("热油");
    }

    public abstract void pourVegetable();

    public abstract void pourSauce();

    public void fry() {
        System.out.println("炒菜炒啊炒啊");
    }

    //模板方法 烹饪
    public void cook() {
        pourOil();
        hotOil();
        pourVegetable();
        pourSauce();
        fry();
    }

}
```

```java
package 行为型模式.模板方法模式;

//包菜
public class Baocai extends AbstractClass{


    @Override
    public void pourVegetable() {
        System.out.println("下锅的是包菜");
    }

    @Override
    public void pourSauce() {
        System.out.println("酱料是辣椒");
    }
}
```

```java
package 行为型模式.模板方法模式;

public class Client {
    public static void main(String[] args) {
        Baocai baocai = new Baocai();
        baocai.cook();
    }
}
```





### 3.2 策略模式

```java
package org.example.行为型模式.策略模式;

// 适用于一个类定义了多种算法, 动态切换一种算法的场景
public class Client {
    public static void main(String[] args) {

        Saleman salemanA = new Saleman(new StrategyA());
        salemanA.salesManShow();

        System.out.println("=======");

        Saleman salemanB = new Saleman(new StrategyB());
        salemanB.salesManShow();

    }
}
```

```java
package org.example.行为型模式.策略模式;

//环境类 聚合策略类
public class Saleman {
    private Strategy strategy;

    public Saleman(Strategy strategy) {
        this.strategy = strategy;
    }

    public void salesManShow(){
        strategy.show();
    }
}
```

```java
package org.example.行为型模式.策略模式;
//抽象策略类
public interface Strategy {
    void show();
}
```

```java
package org.example.行为型模式.策略模式;

public class StrategyA implements Strategy{

    @Override
    public void show() {
        System.out.println("买一送一");
    }
}
```

```java
package org.example.行为型模式.策略模式;

public class StrategyB implements Strategy{

    @Override
    public void show() {
        System.out.println("八折");
    }
}
```

```java
package org.example.行为型模式.策略模式;

public class StrategyC implements Strategy{

    @Override
    public void show() {
        System.out.println("满200减50");
    }
}
```



### 3.3 命令模式

```java
package org.example.行为型模式.命令模式;

// 厨师类
public class Chef {
    public void makeFood(String name , int num){
        System.out.println(num + "份" + name);
    }
}
```

```java
package org.example.行为型模式.命令模式;

public class Client {
    public static void main(String[] args) {
        // 创建第一个订单
        Order order1 = new Order();
        order1.setOrderTable(30);
        order1.setFood("西红柿鸡蛋面",1);
        order1.setFood("小可乐",2);

        // 创建第二个订单
        Order order2 = new Order();
        order2.setOrderTable(44);
        order2.setFood("宫保鸡丁盖饭",1);
        order2.setFood("小雪碧",1);

        //创建厨师对象
        Chef chef = new Chef();

        //创建命令对象
        OrderCommand cmd1 = new OrderCommand(chef, order1);
        OrderCommand cmd2 = new OrderCommand(chef, order2);

        //创建服务员
        Waitor invoke = new Waitor();
        invoke.setCommand(cmd1);
        invoke.setCommand(cmd2);


        //服务员发起调用
        invoke.orderUp();

    }
}
```

```java
package org.example.行为型模式.命令模式;


//抽象命令
public interface Command {
    void execute();

}
```

```java
package org.example.行为型模式.命令模式;

import java.util.HashMap;
import java.util.Map;

public class Order {
    //餐桌号码
    private int orderTable;

    //下单的餐品和份数
    private Map<String, Integer> foodDir = new HashMap<String, Integer>();

    public int getOrderTable() {
        return orderTable;
    }

    public void setOrderTable(int orderTable) {
        this.orderTable = orderTable;
    }

    public Map<String, Integer> getFoodDir() {
        return foodDir;
    }

    public void setFood(String name, int num) {
        foodDir.put(name, num);
    }
}
```

```java
package org.example.行为型模式.命令模式;

import java.util.Map;
import java.util.Set;

// 具体命令
public class OrderCommand implements  Command{
    private Chef chef;

    private Order order;

    public OrderCommand(Chef chef, Order order) {
        this.chef = chef;
        this.order = order;
    }

    @Override
    public void execute() {
        System.out.println(order.getOrderTable() + "桌的订单");
        Map<String,Integer> foodDir = order.getFoodDir();
        Set<String> keys = foodDir.keySet();

        for (String foodname: keys) {
            chef.makeFood(foodname, foodDir.get(foodname));

        }

        System.out.println(order.getOrderTable() + "桌的饭准备好了");
    }


}
```

```java
package org.example.行为型模式.命令模式;

import java.util.ArrayList;
import java.util.List;

//服务员类 调用者角色
public class Waitor {
    private List<Command> Commands = new ArrayList<Command>();
    public void setCommand(Command cmd) {
        Commands.add(cmd);

    }

    public void orderUp() {
        System.out.println("服务员: 新的订单来了");

        for(Command command : Commands ) {
            if (command != null) {
                command.execute();
            }
        }
    }
}
```



### 3.4 职责链模式

```java
package org.example.行为型模式.责任链模式;

//定义
//应用场景
//优缺点
//jdk中的应用


public class Client {
    public static void main(String[] args) {
        // 创建请假条对象
        LeaveRequest request = new LeaveRequest("小明",1,"身体不舒服");

        //创建各级领导对象
        GroupLeader groupLeader = new GroupLeader();
        Manager manager = new Manager();
        GeneralManager generalManager = new GeneralManager();

        // 设置责任链
        groupLeader.setNextHandle(manager);
        manager.setNextHandle(generalManager);

        // 提交申请
        groupLeader.submit(request);

    }
}
```

```java
package org.example.行为型模式.责任链模式;

//董事长类
public class GeneralManager extends Handle{


    protected GeneralManager() {
        super( Handle.NUM_THREE,Handle.NUM_SEVEN);

    }

    @Override
    protected void handleLeave(LeaveRequest leave) {
        System.out.println(leave.getName() + "请假" + leave.getNum() + "天" + leave.getContent());

        System.out.println("总经理正在审批");
    }
}
```

```java
package org.example.行为型模式.责任链模式;

import java.util.logging.Handler;

//小组长类
public class GroupLeader extends Handle{


    protected GroupLeader() {
        super(0, Handle.NUM_ONE);

    }

    @Override
    protected void handleLeave(LeaveRequest leave) {
        System.out.println(leave.getName() + "请假" + leave.getNum() + "天" + leave.getContent());

        System.out.println("小组长正在审批");
    }
}
```

```java
package org.example.行为型模式.责任链模式;

//抽象处理者类
public abstract class Handle {
    protected final static  int NUM_ONE = 1;
    protected final static  int NUM_THREE = 3;
    protected final static  int NUM_SEVEN = 7;

    private int numStart;
    private int numEnd;

    // 上级领导
    private Handle nextHandle;

    public Handle(int numStart, int numEnd) {
        this.numStart = numStart;
        this.numEnd = numEnd;
    }

    public Handle(int numStart) {
        this.numStart = numStart;
    }

    public void setNextHandle(Handle nextHandle) {
        this.nextHandle = nextHandle;
    }

    //处理请假条的方法
    protected  abstract  void handleLeave(LeaveRequest leave);

    //提交请求
    public final void submit(LeaveRequest leave) {
        this.handleLeave(leave);
//        System.out.println(leave.getNum());
//        System.out.println(this.numEnd);

        if (this.nextHandle != null && leave.getNum() > this.numEnd) {
            System.out.println("当前审批未通过,正在请求上级领导");
            this.nextHandle.submit(leave);
        }else if(leave.getNum() <= this.numEnd){
            System.out.println("审批通过,流程结束");
        }else {
            System.out.println("当前审批未通过,最高不能超过7天");

        }
    }
}
```

```java
package org.example.行为型模式.责任链模式;

public class LeaveRequest {
    private String name;
    private int num;

    private String content;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public LeaveRequest(String name, int num, String content) {
        this.name = name;
        this.num = num;
        this.content = content;
    }
}
```

```java
package org.example.行为型模式.责任链模式;

//部门经理类
public class Manager extends Handle{


    protected Manager() {
        super( Handle.NUM_ONE,Handle.NUM_THREE);

    }

    @Override
    protected void handleLeave(LeaveRequest leave) {
        System.out.println(leave.getName() + "请假" + leave.getNum() + "天" + leave.getContent());

        System.out.println("部门经理正在审批");
    }
}
```





### 3.5 状态模式

```java
package org.example.行为型模式.状态模式;

public class Client {
    public static void main(String[] args) {
        Context context = new Context();

        context.setLiftState(new CloseState());
        context.open();
        context.close();
        context.run();
        context.stop();
    }
}
```

```java
package org.example.行为型模式.状态模式;

public class CloseState extends LiftState{

    @Override
    public void open() {
        super.context.setLiftState(Context.OPEN_STATE);
        super.context.open();
    }

    @Override
    public void close() {
        System.out.println("电梯门关闭...");
    }

    @Override
    public void run() {
        super.context.setLiftState(Context.RUN_STATE);
        super.context.run();
    }

    @Override
    public void stop() {
        super.context.setLiftState(Context.STOP_STATE);
        super.context.stop();
    }
}
```

```java
package org.example.行为型模式.状态模式;

//环境角色类
public class Context {
    public final static OpenState OPEN_STATE = new OpenState();
    public final static CloseState CLOSE_STATE = new CloseState();
    public final static RunState RUN_STATE = new RunState();
    public final static StopState STOP_STATE = new StopState();

    private LiftState liftState;

    public LiftState getLiftState() {
        return liftState;
    }

    public void setLiftState (LiftState liftState){
        this.liftState = liftState;
        this.liftState.setContext(this);
    }

    public void open(){
        this.liftState.open();
    }

    public void close(){
        this.liftState.close();
    }


    public void stop(){
        this.liftState.stop();
    }


    public void run(){
        this.liftState.run();
    }




}
```

```java
package org.example.行为型模式.状态模式;

//抽象状态类
public abstract class LiftState {
    //环境角色
    protected Context context;
    public void setContext(Context context) {
        this.context = context;
    }

    //
    public abstract void open();
    public abstract void close();
    public abstract void run();
    public abstract void stop();
}
```

```java
package org.example.行为型模式.状态模式;

public class OpenState extends LiftState{

    //当前状态要执行的方法
    @Override
    public void open() {
        System.out.println("电梯开启...");
    }

    @Override
    public void close() {
        super.context.setLiftState(Context.CLOSE_STATE);
        super.context.close();
    }

    @Override
    public void run() {

    }

    @Override
    public void stop() {

    }
}
```

```java
package org.example.行为型模式.状态模式;

public class RunState extends LiftState{

    @Override
    public void open() {

    }

    @Override
    public void close() {

    }

    @Override
    public void run() {
        System.out.println("电梯正在运行...");
    }

    @Override
    public void stop() {
        super.context.setLiftState(Context.STOP_STATE);
        super.context.stop();
    }
}
```

```java
package org.example.行为型模式.状态模式;

public class StopState extends LiftState{

    @Override
    public void open() {
        super.context.setLiftState(Context.OPEN_STATE);
        super.context.open();
    }

    @Override
    public void close() {
        super.context.setLiftState(Context.CLOSE_STATE);
        super.context.close();
    }

    @Override
    public void run() {
        super.context.setLiftState(Context.RUN_STATE);
        super.context.run();
    }

    @Override
    public void stop() {
        System.out.println("电梯停止了...");
    }
}
```



### 3.6 观察者模式

```java
package org.example.行为型模式.中介者模式;

public class Client {
    public static void main(String[] args) {
        MediatorStructure mediatorStructure = new MediatorStructure();

        Tenant tenant = new Tenant("租客",mediatorStructure);

        HouseOwner houseOwner = new HouseOwner("房主",mediatorStructure);

        mediatorStructure.setTenant(tenant);
        mediatorStructure.setOwner(houseOwner);

        tenant.constact("我想要租房子");
        houseOwner.constact("我这里有三间房,你要租吗");
    }
}
```

```java
package org.example.行为型模式.观察者模式;

//抽象观察者接口
public interface Observer {
    void updata(String mes);
}
```

```java
package org.example.行为型模式.观察者模式;

//抽象主题角色类
public interface Subject {
    //添加订阅者
    void attach(Observer observer);

    //删除订阅者
    void detach(Observer observer);

    //通知
    void notify(String message);

}
```

```java
package org.example.行为型模式.观察者模式;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.List;

// 具体主题角色类
public class SubscriptSubject implements Subject{

    //储存观察者对象
    private List<Observer> weixinUserList = new ArrayList<Observer>() ;


    //新增
    @Override
    public void attach(Observer observer) {
        weixinUserList.add(observer);
    }

    //删除
    @Override
    public void detach(Observer observer) {
        weixinUserList.remove(observer);
    }

    //通知
    @Override
    public void notify(String message) {
        for (Observer observer : weixinUserList) {
            observer.updata(message);
        }
    }
}
```

```java
package org.example.行为型模式.观察者模式;

//具体观察者角色类
public class WexinUser implements  Observer{
    private String name;

    public WexinUser(String name) {
        this.name = name;
    }

    @Override
    public void updata(String msg) {
        System.out.println(name + "-" + msg);
    }
}
```



### 3.7 中介者模式

```java
package org.example.行为型模式.中介者模式;

public class Client {
    public static void main(String[] args) {
        MediatorStructure mediatorStructure = new MediatorStructure();

        Tenant tenant = new Tenant("租客",mediatorStructure);

        HouseOwner houseOwner = new HouseOwner("房主",mediatorStructure);

        mediatorStructure.setTenant(tenant);
        mediatorStructure.setOwner(houseOwner);

        tenant.constact("我想要租房子");
        houseOwner.constact("我这里有三间房,你要租吗");
    }
}
```

```java
package org.example.行为型模式.中介者模式;

// 具体同事角色类
public class HouseOwner extends  Person{


    public HouseOwner(String name, Mediator mediator) {
        super(name, mediator);
    }


    //联系中介
    public void constact(String message) {
        mediator.constact(message, this);

    }

    //获取信息
    public void getMessage(String message) {
        System.out.println("房主" + name + "收到的信息是:" + message);
    }
}
```

```java
package org.example.行为型模式.中介者模式;

//抽象中介者
public abstract class Mediator {
    public abstract void constact(String message , Person person);
}
```

```java
package org.example.行为型模式.中介者模式;

//具体中介者角色类
public class MediatorStructure extends Mediator{
    //聚合房主和租房者对象
    private HouseOwner owner;
    private Tenant tenant;

    public HouseOwner getOwner() {
        return owner;
    }

    public void setOwner(HouseOwner owner) {
        this.owner = owner;
    }

    public Tenant getTenant() {
        return tenant;
    }

    public void setTenant(Tenant tenant) {
        this.tenant = tenant;
    }


    @Override
    public void constact(String message, Person person) {
        if (person == owner) {
            tenant.getMessage(message);
        }else {
            owner.getMessage(message);
        }
    }
}
```

```java
package org.example.行为型模式.中介者模式;


//抽象同事类
public abstract class Person {
    protected  String name;
    protected  Mediator mediator;

    public Person(String name, Mediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }
}
```

```java
package org.example.行为型模式.中介者模式;

// 具体同事角色类
public class Tenant extends Person{
    public Tenant(String name, Mediator mediator) {
        super(name, mediator);
    }

    //联系中介
    public void constact(String message) {
        mediator.constact(message, this);

    }

    //获取信息
    public void getMessage(String message) {
        System.out.println("租房者" + name + "收到的信息是:" + message);
    }
}
```





### 3.8 迭代器模式

```java
package org.example.行为型模式.迭代器模式;

public class Client {
    public static void main(String[] args) {
        StudentAggregateImpl studentAggregate = new StudentAggregateImpl();
        studentAggregate.addStudent(new Student("张三" , "001"));
        studentAggregate.addStudent(new Student("李四" , "002"));
        studentAggregate.addStudent(new Student("王五" , "003"));
        studentAggregate.addStudent(new Student("赵六" , "004"));


        StudentIterator iterator = studentAggregate.getStudentIterator();

        while (iterator.hasNext()){
            Student student = iterator.next();
            System.out.println(student.toString());
        }
    }
}
```

```java
package org.example.行为型模式.迭代器模式;

public class Student {
    private String name;
    private String number;

    public Student(){

    }

    public Student(String name, String number) {
        this.name = name;
        this.number = number;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", number='" + number + '\'' +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }
}
```

```java
package org.example.行为型模式.迭代器模式;

//抽象聚合角色接口
public interface StudentAggregate {

    //添加
    void addStudent(Student student);

    //删除
    void removeStudent(Student student);

    //获取迭代器
    StudentIterator getStudentIterator();
}
```

```java
package org.example.行为型模式.迭代器模式;

import java.util.ArrayList;
import java.util.List;

public class StudentAggregateImpl implements StudentAggregate{
    private List<Student> list =new ArrayList<Student>();


    @Override
    public void addStudent(Student student) {
        list.add(student);
    }

    @Override
    public void removeStudent(Student student) {
        list.remove(student);
    }

    @Override
    public StudentIterator getStudentIterator() {
        return new StudentIteratorImpl(list);
    }
}
```

```java
package org.example.行为型模式.迭代器模式;

//抽象迭代器角色接口
public interface StudentIterator {
    boolean hasNext();

    Student next();
}
```

```java
package org.example.行为型模式.迭代器模式;

import java.util.List;

//据图迭代器角色类
public class StudentIteratorImpl implements StudentIterator{
    private List<Student> list;
    private int position = 0;

    @Override
    public boolean hasNext() {
        return position < list.size();
    }

    public StudentIteratorImpl(List<Student> list) {
        this.list = list;
    }

    @Override
    public Student next() {
        Student currentstudent = list.get(position);
        position++;

        return currentstudent;
    }
}
```



### 3.9 解释器模式

```java
package org.example.行为型模式.解释器模式;


//抽象表达式类
public abstract class AbstractExpression {
    public abstract int interpret (Content content);
}
```

```java
package org.example.行为型模式.解释器模式;

public class Client {
    public static void main(String[] args) {
         Content content = new Content();

         Variable a = new Variable("a");
         Variable b = new Variable("b");
         Variable c = new Variable("c");
         Variable d = new Variable("d");

         content.assign(a,1);
         content.assign(b,2);
         content.assign(c,3);
         content.assign(d,4);

         AbstractExpression expression = new Minus(a, new Plus( new Minus(b,c),d));
         int result = expression.interpret(content);

        System.out.println(expression + "=" + result);
    }
}
```

```java
package org.example.行为型模式.解释器模式;

import java.util.HashMap;
import java.util.Map;

//环境角色类
public class Content {
    private Map<Variable, Integer> map = new HashMap<Variable, Integer>();

    public void assign(Variable variable , Integer value) {
        map.put(variable, value);

    }

    public int getValue(Variable variable) {
        return map.get(variable);
    }
}
```

```java
package org.example.行为型模式.解释器模式;

//减法表达式类
public class Minus extends  AbstractExpression{

    private AbstractExpression left;

    public Minus(AbstractExpression left, AbstractExpression right) {
        this.left = left;
        this.right = right;
    }

    private AbstractExpression right;

    @Override
    public int interpret(Content content) {
        return left.interpret(content) - right.interpret(content);
    }

    @Override
    public String toString() {
        return "(" + left.toString() + "-" + right.toString() + ")";

    }
}
```

```java
package org.example.行为型模式.解释器模式;

//加法表达式类
public class Plus extends  AbstractExpression{

    private AbstractExpression left;

    public Plus(AbstractExpression left, AbstractExpression right) {
        this.left = left;
        this.right = right;
    }

    private AbstractExpression right;

    @Override
    public int interpret(Content content) {
        return left.interpret(content) + right.interpret(content);
    }

    @Override
    public String toString() {
        return "(" + left.toString() + "+" + right.toString() + ")";

    }
}
```

```java
package org.example.行为型模式.解释器模式;

// 变量类
public class Variable extends  AbstractExpression{

    //声明存储变量名的成员变量
    private String name;

    public Variable(String name) {
        this.name = name;
    }

    @Override
    public int interpret(Content content) {
        return content.getValue(this);
    }

    @Override
    public String toString() {
        return name;
    }
}
```



### 3.10 备忘录模式

##### 白盒测试

```java
package org.example.行为型模式.备忘录模式.白盒;

//白盒备忘录 客户端和管理者不能操作备忘录
public class Client {
    public static void main(String[] args) {


        System.out.println("-----------大战boss前----------");
        //创建对象
        GameRole gameRole =  new GameRole();
        // 初始化
        gameRole.init();
        //展示
        gameRole.stateDisplay();

        //备份
        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());

        System.out.println("-----------大战boss后----------");
        // 损耗严重
        gameRole.fight();
        //展示
        gameRole.stateDisplay();

        System.out.println("-----------重新挑战----------");
        //恢复之前的状态
        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());
        //展示
        gameRole.stateDisplay();


    }
}
```

```java
package org.example.行为型模式.备忘录模式.白盒;

public class GameRole {
    private  int vit;
    private int atk;

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    private int def;

    //初始化
    public void init() {
        this.vit = 100;
        this.atk = 100;
        this.def = 100;
    }

    //战斗
    public void fight() {
        this.vit = 0;
        this.atk = 0;
        this.def = 0;
    }

    //保存角色状态
    public RoleStateMemento saveState() {
        return new RoleStateMemento(vit, atk ,def);
    }


    //恢复状态
    public void recoverState(RoleStateMemento roleStateMemento){
        this.vit = roleStateMemento.getVit();
        this.atk = roleStateMemento.getAtk();
        this.def = roleStateMemento.getDef();


    }

    //展示状态功能
    public void stateDisplay(){
        System.out.println("角色生命:" + vit);
        System.out.println("角色攻击:" + atk);
        System.out.println("角色防御:" + def);
    }

}
```

```java
package org.example.行为型模式.备忘录模式.白盒;

public class RoleStateCaretaker {
    private RoleStateMemento roleStateMemento;

    public RoleStateMemento getRoleStateMemento() {
        return roleStateMemento;
    }

    public void setRoleStateMemento(RoleStateMemento roleStateMemento) {
        this.roleStateMemento = roleStateMemento;
    }
}
```

```java
package org.example.行为型模式.备忘录模式.白盒;

// 备忘录角色类 存储历史状态
public class RoleStateMemento {
    private  int vit;
    private int atk;
    private int def;

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    public RoleStateMemento() {

    }

    public RoleStateMemento(int vit, int atk, int def) {
        this.vit = vit;
        this.atk = atk;
        this.def = def;
    }
}
```



##### 黑盒测试

```java
package org.example.行为型模式.备忘录模式.黑盒;



//白盒备忘录 客户端和管理者不能操作备忘录
public class Client {
    public static void main(String[] args) {


        System.out.println("-----------大战boss前----------");
        //创建对象
       GameRole gameRole =  new GameRole();
        // 初始化
        gameRole.init();
        //展示
        gameRole.stateDisplay();

        //备份
       RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setMemento(gameRole.saveState());

        System.out.println("-----------大战boss后----------");
        // 损耗严重
        gameRole.fight();
        //展示
        gameRole.stateDisplay();

        System.out.println("-----------重新挑战----------");
        //恢复之前的状态
        gameRole.recoverState(roleStateCaretaker.getMemento());
        //展示
        gameRole.stateDisplay();


    }
}
```

```java
package org.example.行为型模式.备忘录模式.黑盒;


public class GameRole {
    private  int vit;
    private int atk;
    private int def;

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }



    //初始化
    public void init() {
        this.vit = 100;
        this.atk = 100;
        this.def = 100;
    }

    //战斗
    public void fight() {
        this.vit = 0;
        this.atk = 0;
        this.def = 0;
    }

    //保存角色状态
    public RoleStateMemento saveState() {
        return new RoleStateMemento(vit, atk ,def);
    }


    //恢复状态
    public void recoverState(Memento memento){
        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;

        this.vit = roleStateMemento.getVit();
        this.atk = roleStateMemento.getAtk();
        this.def = roleStateMemento.getDef();


    }

    //展示状态功能
    public void stateDisplay(){
        System.out.println("角色生命:" + vit);
        System.out.println("角色攻击:" + atk);
        System.out.println("角色防御:" + def);
    }


    //私有内部类
    private class RoleStateMemento implements Memento {
        private  int vit;
        private int atk;

        public int getVit() {
            return vit;
        }

        public void setVit(int vit) {
            this.vit = vit;
        }

        public int getAtk() {
            return atk;
        }

        public void setAtk(int atk) {
            this.atk = atk;
        }

        public int getDef() {
            return def;
        }

        public void setDef(int def) {
            this.def = def;
        }

        public RoleStateMemento() {
        }

        public RoleStateMemento(int vit, int atk, int def) {
            this.vit = vit;
            this.atk = atk;
            this.def = def;
        }

        private int def;
    }
}
```

```java
package org.example.行为型模式.备忘录模式.黑盒;

//备忘录接口 对外提供窄接口
public interface Memento {
}
```

```java
package org.example.行为型模式.备忘录模式.黑盒;

import org.example.行为型模式.备忘录模式.白盒.RoleStateMemento;

public class RoleStateCaretaker {
    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
```



### 3.11 访问者模式

```java
package org.example.行为型模式.访问者模式;

//抽象元素角色
public interface Animal {
    //
    void  accept(Person person);

}
```

```java
package org.example.行为型模式.访问者模式;

//具体元素角色类
public class Cat implements  Animal{
    @Override
    public void accept(Person person) {
        person.feed(this);
        System.out.println("喵喵喵");
    }
}
```

```java
package org.example.行为型模式.访问者模式;

public class Client {
    public static void main(String[] args) {
        Home home = new Home();
        home.add(new Cat());
        home.add(new Dog());

        Owner owner = new Owner();
        home.action(owner);

    }
}
```

```java
package org.example.行为型模式.访问者模式;

public class Dog implements  Animal{
    @Override
    public void accept(Person person) {
        person.feed(this);
        System.out.println("汪汪汪");
    }
}
```

```java
package org.example.行为型模式.访问者模式;

import java.util.ArrayList;
import java.util.List;

//对象结构类
public class Home {
    //
    private List<Animal> nodeList = new ArrayList<Animal>();

    public void add (Animal animal) {
        nodeList.add(animal);
    }

    public void action(Person person) {
        for (Animal animal : nodeList) {
            animal.accept(person);
        }
    }
}
```

```java
package org.example.行为型模式.访问者模式;

//具体访问者角色类 自己
public class Owner implements Person{
    @Override
    public void feed(Cat cat) {
        System.out.println("主人喂猫");
    }

    @Override
    public void feed(Dog dog) {
        System.out.println("主人喂狗");
    }
}
```

```java
package org.example.行为型模式.访问者模式;

//抽象访问者角色接口
public interface Person {
    void feed(Cat cat);
    void feed(Dog dog);


}
```

```java
package org.example.行为型模式.访问者模式;

//具体访问者角色类 其他人
public class Someone implements Person{
    @Override
    public void feed(Cat cat) {
        System.out.println("其他人喂猫");
    }

    @Override
    public void feed(Dog dog) {
        System.out.println("其他人喂狗");
    }
}
```





## 第4章 结构型设计模式

### 4.1 代理模式

#### 4.1.1 定义

#### 4.1.2 特点

#### 4.1.3 优点和缺点

#### 4.1.4 应用场景

##### 静态代理

```java
package 代理模式.静态代理;

public class Client {
    public static void main(String[] args) {
        ProxyPoint proxy = new ProxyPoint();
        proxy.sell();
    }
}
```

```java
package 代理模式.静态代理;

//代售点
public class ProxyPoint implements SellTickets{

    private TranStation tranStation = new TranStation();

    @Override
    public void sell() {
        System.out.println("收取中介费");
        tranStation.sell();

    }
}
```

```java
package 代理模式.静态代理;

//抽象类
public interface SellTickets {
    void sell();
}
```

```java
package 代理模式.静态代理;

//火车站
public class TranStation implements SellTickets{
    @Override
    public void sell() {
        System.out.println("火车站卖票");
    }
}
```



##### jdk动态代理

```java
package 代理模式.jdk动态代理;

public class Client {
    public static void main(String[] args) {
        ProxyFactory factory = new ProxyFactory();
        SellTickets proxyObject = factory.getProxyObject();
        proxyObject.sell();
    }
}
```

```java
package 代理模式.jdk动态代理;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory {
    private TranStation station = new TranStation();

    public SellTickets getProxyObject(){
        SellTickets proxyObject = (SellTickets) Proxy.newProxyInstance(
                station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {

                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("代售点收取费用");

                        Object obj = method.invoke(station, args);
                        return obj;
                    }
                }
        );

        return proxyObject;
    };
}
```

```java
package 代理模式.jdk动态代理;

//抽象类
public interface SellTickets {
    void sell();
}
```

```java
package 代理模式.jdk动态代理;

//火车站
public class TranStation implements SellTickets {
    @Override
    public void sell() {
        System.out.println("火车站卖票");
    }
}
```



##### cglib动态代理







#### 4.1.5 结构与实现







### 4.2 适配器模式

```java
package 适配器模式;

// 电脑可以直接读取sd卡数据 不能读取tf卡数据
// 使用适配器可以读取tf卡
public class Client {
    public static void main(String[] args) {

        //以下代码为直接读取sd卡
        Computer computer = new Computer();
        String msg = computer.readSD(new SDCardImpl());
        System.out.println(msg);

        System.out.println("==========");

        //以下代码适配读取tf卡
        SD2TF sd2TF = new SD2TF(new TFCardImpl());
        String s = computer.readSD(sd2TF);
        System.out.println(s);
    }
}
```

```java
package 适配器模式;

public class Computer {
    public String readSD(SDCard sdCard) {
        if(sdCard==null) {
            throw new NullPointerException("sd卡不能为空");

        }
        return sdCard.readSD();
    }
}
```

```java
package 适配器模式;

// 适配器类
public class SD2TF  implements SDCard{

    private TFCard tfcard;

    public SD2TF(TFCard tfcard) {
        this.tfcard = tfcard;
    }

    @Override
    public String readSD() {
        System.out.println("sd适配tf读取");
        return tfcard.readTF();
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("sd适配tf写入");
        tfcard.writeTF(msg);
    }
}
```

```java
package 适配器模式;

// 目标接口
public interface SDCard {
    String readSD();

    void writeSD(String msg);

}
```

```java
package 适配器模式;

//
public class SDCardImpl implements SDCard{

    @Override
    public String readSD() {
        String msg = "读取SD卡";
        return msg;
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("SD卡写入" + msg);
    }
}
```

```java
package 适配器模式;

//适配接口
public interface TFCard {
    String readTF();

    void writeTF(String msg);
}
```

```java
package 适配器模式;

public class TFCardImpl implements TFCard{

    @Override
    public String readTF() {
        String msg = "读取TF卡";
        return msg;
    }

    @Override
    public void writeTF(String msg) {
        System.out.println("写入TF卡" + msg);
    }
}
```





### 4.3 装饰器模式

```java
package 装饰器模式;

// 培根类 具体装饰者角色
public class Bacon extends Garnish{
    public Bacon(FastFood fastfood){
        super(fastfood,5,"培根");
    }

    @Override
    public float cost() {
        return getPrice() + getFastFood().cost();
    }

    @Override
    public String getDesc(){
        return super.getDesc() + getFastFood().getDesc();
    }
}
```

```java
package 装饰器模式;

public class Client {
    public static void main(String[] args) {
        FastFood food = new FriedRice();

        System.out.println(food.getDesc());
        System.out.println(food.cost());
        System.out.println("========");

        // 添加一个鸡蛋
        food = new Egg(food);
        System.out.println(food.getDesc());
        System.out.println(food.cost());
        System.out.println("========");

        //再添加一个鸡蛋
        food = new Egg(food);
        System.out.println(food.getDesc());
        System.out.println(food.cost());
        System.out.println("========");


        //再添加一个培根
        food = new Bacon(food);
        System.out.println(food.getDesc());
        System.out.println(food.cost());
        System.out.println("========");



    }
}
```

```java
package 装饰器模式;

// 鸡蛋类 具体装饰者角色
public class Egg extends Garnish{
    public Egg(FastFood fastfood){
        super(fastfood,1,"鸡蛋");
    }

    @Override
    public float cost() {
        return getPrice() + getFastFood().cost();
    }

    @Override
    public String getDesc(){
        return super.getDesc() + getFastFood().getDesc();
    }
}
```

```java
package 装饰器模式;

//抽象构建角色
public abstract class FastFood {
    private float price; //价格
    private String desc; //描述

    public FastFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public FastFood(){

    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public abstract float cost();

}
```

```java
package 装饰器模式;

//具体构建角色 炒面

public class FriedNoodles extends FastFood{
    public  FriedNoodles(){
        super(12,"炒面");
    }

    @Override
    public float cost() {
        return getPrice();
    }
}
```

```java
package 装饰器模式;

// 具体构建角色 炒饭
public class FriedRice extends FastFood{
    public FriedRice(){
        super(10,"炒饭");
    }

    @Override
    public float cost() {
        return getPrice();
    }
}
```

```java
package 装饰器模式;

// 装饰者类 抽象装饰角色
public abstract class Garnish extends FastFood{
    private FastFood fastFood;

    public FastFood getFastFood() {
        return fastFood;
    }

    public void setFastFood(FastFood fastFood) {
        this.fastFood = fastFood;

    }

    public Garnish(FastFood fastFood,float price , String desc) {
        super(price,desc);
        this.fastFood = fastFood;
    }
}
```







### 4.4 桥接模式

```java
package 桥接模式;

// avi视频文件 具体实现化角色
public class AviFIle implements VideoFile{

    @Override
    public void decode(String filename) {
        System.out.println("avi视频" + filename);
    }
}
```

```java
package 桥接模式;

//适合两个独立的维度 并且两个维度都进行拓展
//
public class Client {
    public static void main(String[] args) {
        OpratingSystem opratingSystem = new Mac(new AviFIle());
        opratingSystem.play("战狼3");
    }
}
```

```java
package 桥接模式;

public class Mac extends OpratingSystem{

    public Mac(VideoFile videoFile){
        super(videoFile);
    }

    @Override
    public void play(String fileName) {
        videoFile.decode(fileName);
    }
}
```

```java
package 桥接模式;

// 抽象化角色
public abstract class OpratingSystem {
    protected VideoFile videoFile;

    public OpratingSystem(VideoFile videoFile) {
        this.videoFile = videoFile;
    }

    public abstract void play(String fileName);
}
```

```java
package 桥接模式;

// rmvb 具体实现化角色
public class RmvbFIle implements VideoFile{
    @Override
    public void decode(String filename) {
        System.out.println("rmvb视频文件" + filename);

    }
}
```

```java
package 桥接模式;

// 实现化角色
public interface VideoFile {
    void decode(String filename);
}
```

```java
package 桥接模式;

// 扩展抽象化角色
public class Windows extends OpratingSystem{
    public Windows(VideoFile videofile) {
        super(videofile);
    }

    @Override
    public void play(String fileName) {
        videoFile.decode(fileName);
    }

}
```





### 4.5 组合模式

```java
package 组合模式;

//适合树形结构
public class Client {
    public static void main(String[] args) {

        //创建菜单树
        MenuComponent menu1 = new Menu("菜单管理",2);
        menu1.add(new MenuItem("页面访问",3));
        menu1.add(new MenuItem("展开菜单",3));
        menu1.add(new MenuItem("编辑菜单",3));
        menu1.add(new MenuItem("新增菜单",3));
        menu1.add(new MenuItem("删除菜单",3));


        MenuComponent menu2 = new Menu("权限管理",2);
        menu2.add(new MenuItem("提交保存",3));

        MenuComponent menu3 = new Menu("角色管理",2);
        menu3.add(new MenuItem("新增角色",3));
        menu3.add(new MenuItem("修改角色",3));


        MenuComponent rootmenu = new Menu("系统管理",1);
        rootmenu.add(menu1);
        rootmenu.add(menu2);
        rootmenu.add(menu3);

        rootmenu.printname();

    }
}
```

```java
package 组合模式;

import java.util.ArrayList;
import java.util.List;

// 菜单类 树枝节点角色
public class Menu extends MenuComponent{
    private List<MenuComponent> menuComponentList = new ArrayList<MenuComponent>();

    public Menu(String name, int  level) {
        this.name = name;
        this.level = level;
    }


    @Override
    public void add(MenuComponent menucomponent) {
        menuComponentList.add(menucomponent);
    }

    @Override
    public void remove(MenuComponent menucomponent) {
        menuComponentList.remove(menucomponent);
    }

    @Override
    public MenuComponent getChildren(int index) {
        return super.getChildren(index);
    }

    @Override
    public void printname() {
        //层级
        for (int i = 0; i< level ; i++) {
            System.out.print("--");
        }

        //打印菜单名称
        System.out.println(name);
        //打印子菜单名称
        for (MenuComponent menuComponent : menuComponentList) {
            menuComponent.printname();
        }

    }
}
```

```java
package 组合模式;

// 抽象根节点
public abstract class MenuComponent {
    protected String name;
    protected int level;

    public void add(MenuComponent menucomponent) {
        throw new UnsupportedOperationException();
    }

    public void remove(MenuComponent menucomponent) {
        throw new UnsupportedOperationException();

    }

    // 获取指定子菜单
    public MenuComponent getChildren(int index) {
        throw new UnsupportedOperationException();
    }

    // 获取菜单或菜单项名称
    public String getName() {
        return name;
    }

    //打印菜单名称
    public abstract void printname();
}
```

```java
package 组合模式;


// 叶子节点角色
public class MenuItem extends MenuComponent{
    public MenuItem(String name, int level) {
        this.name = name;
        this.level = level;

    }
    @Override
    public void printname() {
        //层级
        for (int i = 0; i< level ; i++) {
            System.out.print("--");
        }
        System.out.println(name);
    }
}
```





### 4.6 外观模式

```java
package 外观模式;

public class Air {
    public void on() {
        System.out.println("打开空调");
    }

    public void off(){
        System.out.println("关闭空调");
    }
}
```

```java
package 外观模式;

public class Client {

    public static void main(String[] args) {
        SmartApp smartApp = new SmartApp();
        smartApp.say("早上打开家电");

        smartApp.say("晚上关闭家电");
    }
}
```

```java
package 外观模式;

public class Light {
    public void on() {
        System.out.println("打开台灯");
    }

    public void off(){
        System.out.println("关闭台灯");
    }
}
```

```java
package 外观模式;

public class SmartApp {
    private Light light;
    private TV tv;
    private Air air;

    public SmartApp() {
        light = new Light();
        tv = new TV();
        air = new Air();

    }


    public void say(String message) {
        if (message.contains("打开")){
            on();
        }else if (message.contains("关闭")){
            off();
        }
    }

    //一键开启
    private void on() {
        light.on();
        tv.on();
        air.on();
    }


    //一键关闭
    private void off() {
        light.off();
        tv.off();
        air.off();
    }
}
```

```java
package 外观模式;

public class TV {
    public void on() {
        System.out.println("打开电视");
    }

    public void off(){
        System.out.println("关闭电视");
    }
}
```





### 4.7 享元模式

```java
package 享元模式;

// 抽象享元角色
public abstract class AbstractBox {
    //获取图形
    public abstract String getShape();

    // 显示图形和颜色
    public void display(String color ) {
        System.out.println("方块形状:" + getShape() + ",颜色:" + color);

    }

}
```

```java
package 享元模式;

import java.util.HashMap;

// 工厂类单例模式
public class BoxFactory {
    private HashMap<String, AbstractBox > map;

    private BoxFactory(){
        map = new HashMap<String, AbstractBox>();
        map.put("I", new IBox());
        map.put("O", new OBox());
        map.put("L", new LBox());

    }

    public static BoxFactory factory = new BoxFactory();

    public static BoxFactory getInstance() {
        return factory;

    }


    public AbstractBox getShape(String name) {
        return map.get(name);
    }

}
```

```java
package 享元模式;


// 场景 需要多次重复使用享元对象
// 内部状态 不会随着环境的改变而改变的共享部分
// 外部状态 随环境改变而改变的不可以共享的部分

// 优点 减少内存中的相似的对象的数量, 节约系统的资源, 提高系统性能
// 享元模式 分离内部和外部状态,
public class Client {
    public static void main(String[] args) {
        AbstractBox box1 = BoxFactory.getInstance().getShape("I");
        box1.display("灰色");

        AbstractBox box2 = BoxFactory.getInstance().getShape("O");
        box1.display("红色");

        AbstractBox box3 = BoxFactory.getInstance().getShape("L");
        box1.display("蓝色");

        AbstractBox box4 = BoxFactory.getInstance().getShape("I");
        box1.display("绿色");


        System.out.println(box1 == box4);  // 结果为 true
    }
}
```

```java
package 享元模式;


// 具体享元角色  I形状 方块
public class IBox extends AbstractBox{
    @Override
    public String getShape() {
        return "I";
    }


}
```

```java
package 享元模式;


// 具体享元角色  L形状 方块
public class LBox extends AbstractBox{
    @Override
    public String getShape() {
        return "L";
    }


}
```

```java
package 享元模式;


// 具体享元角色  O形状 方块
public class OBox extends AbstractBox{
    @Override
    public String getShape() {
        return "O";
    }


}
```





## 第5章 UML图

### 5.1 类图概述

### 5.2 类图表示法

### 5.3 类与类之间的关系

关联关系 

聚合关系

组合关系

依赖关系

继承关系

实现关系

